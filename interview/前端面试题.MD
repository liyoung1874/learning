# 前端面试题

## html

1. HTML5 有哪些新特性？

   > [!NOTE]
   >
   > 1. 新的语义化标签，如 header、footer、article、section、nav、aside 等。这些标签是页面结构更加清晰，便于搜索引擎优化（SEO）和开发者理解。
   > 2. 多媒体元素。audio 用于嵌入音频内容，支持原生播放，不依赖插件，video 用于嵌入视频内容，支持多种格式，业无需第三方插件。
   > 3. canvas 和 svg。canvas 可通过 js 动态绘制 2D 图形，适用于游戏、图表等场景。svg 支持矢量图形，适合高质量的可缩放图形。
   > 4. 表单增强。新增输入类型，如 input 的 type = email，url，date，number 等，提升用户体验和表单验证。新增属性，如 placeholder，required，pattern 等，减少 js 的使用。
   > 5. 本地存储。localStorage 用于持久化存储键值对数据，无过期时间。sessionStorage 会话级存储，页面关闭后数据清除。这两者替代了传统的 Cookie, 容量更大，通常为 5 - 10 MB。
   > 6. 地理位置 api，通过 navigator.geoloaction，可以获取用户的地理位置，用于地图和位置相关服务。
   > 7. Web workers，允许在后台线程运行 js，处理复杂计算而不阻塞主线程，提升性能。
   > 8. 拖放 api，通过 draggable 属性和相关事件，如 dragstart、drop 等，实现原生的拖放功能。
   > 9. websocket，提供双向通信协议，支持数据实时传输，适用于聊天，实时游戏等场景。
   > 10. history api，通过 pushState 和 replaceState，可以在不刷新页面的情况下操作浏览器历史记录，方便开发单页面应用。
   > 11. CSS3 支持，虽然 css3 不是 html5 的一部分，但是 html5 的发展与 css3（如动画、过度、flexbox）的紧密结合，共同提升了前端体验。
   >
   > 总的说来，html5 的新特性主要围绕语义化，多媒体，本地化，性能优化和实施通信展开。它减少了对 flash 等插件的依赖，推送了现代 web 应用的普及，比如单页面应用和移动端优化。
   >

2. 什么是语义化 HTML？有哪些好处？

   > [!NOTE]
   >
   > 语义化 html 是指通过使用具有明确语义的 html 标签来描述内容的含义和结构，而不是仅仅关注页面的外观。例如使用 header 表示页眉，nav 表示导航，article 表示文章内容，使得代码不仅是为了浏览器渲染，也是为了表达内容的逻辑和目的，而不是一味的使用 div 和 span 来布局。
   >
   > 语义化的好处
   >
   > 1. 提升了代码的可读性和可维护性，让代码结构一目了然，开发者能够快速理解页面各部分的作用。
   > 2. 搜索引擎优化，搜索引擎更喜欢语义化的结构，因为它能更好的解释页面内容，例如 h1 表示主标题，article 表示文章内容，这些信息有助于爬虫抓取和排名。相比之下，滥用 div 会让搜索引擎难以判断页面的重点。
   > 3. 增强可访问性。屏幕阅读器等辅助技术依赖语义化标签来为视障用户提供更好的体验。例如 nav 会被识别为导航区域，button 明确为可交互元素。
   > 4. 跨设备和浏览器兼容性。语义化标签通常有自己的默认浏览器样式和行为，能更好的适配不同设备，减少 css 的冗余调整。
   > 5. 减少对 css 和 js 的依赖。语义化标签自带一定的结构化特性，比如 header 和 footer 的布局含义清晰，可以较少复杂的类命名或额外的 js 逻辑。
   >
   > 语义化在大型项目中尤为重要，在大型电商项目中，假设有一个 product 标签，那就能清除的区分这是商品区域。总之，语义化 html 是前端开发中的最佳实践，不仅为了代码美观，更是为了用户、搜索引擎和团队协作的长远利益。

3. `<!DOCTYPE>` 的作用是什么？

   > [!NOTE]
   >
   > <!DOCTYPE> 是 HTML 文档开头的声明（Document Type Declaration），用于告诉浏览器当前文档使用的 HTML 或 XHTML 规范版本。它的主要作用是定义文档的解析模式，确保浏览器按照正确的标准渲染页面。
   > 具体作用
   > 指定文档类型和渲染模式
   > 浏览器的渲染引擎有多种模式：
   > 标准模式（Standards Mode）：按照 W3C 标准解析 HTML 和 CSS。
   > 怪异模式（Quirks Mode）：模拟旧浏览器（如 IE5）的非标准行为，向后兼容。
   > 近似标准模式（Almost Standards Mode）：介于两者之间。
   > 如果省略 <!DOCTYPE> 或声明不正确，浏览器会进入怪异模式，导致页面布局和样式可能出现异常。
   > 触发标准模式
   > 现代网页开发中，通常使用 <!DOCTYPE html>（HTML5 的声明），它简洁且明确地告诉浏览器按照最新的 HTML5 标准解析文档。这样浏览器会以标准模式渲染，确保 CSS 和 JavaScript 行为符合预期。
   > 历史背景与兼容性
   > 在 HTML4 和 XHTML 中，<!DOCTYPE> 声明更复杂，指向特定的 DTD（文档类型定义）文件，例如：
   > <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
   > HTML5 简化了这一过程，只需 <!DOCTYPE html>，不再依赖 DTD，兼容性更强。
   > 为什么重要？（面试加分点）
   > 1. 避免怪异模式的问题
   > 在怪异模式下，盒模型（如 IE 的旧盒模型）、行高、字体大小等计算方式可能与标准模式不同，导致跨浏览器兼容性问题。
   > 例如，CSS 的 box-sizing 行为在怪异模式下可能不可控。
   > 前端开发规范
   > <!DOCTYPE> 是现代 Web 开发的标配，确保代码符合 W3C 标准，提升代码质量。
   > 调试便利性
   > 如果页面布局出现问题，检查是否正确声明 <!DOCTYPE> 是排查的第一步。
   > 注意事项
   > <!DOCTYPE> 必须放在 HTML 文件的第一行（注释除外），否则无效。
   > 它对大小写不敏感，例如 <!doctype html> 也有效。
   > 它不是 HTML 标签，而是独立的声明。
   > <!DOCTYPE> 的核心作用是告诉浏览器以何种标准解析文档，直接影响页面的渲染效果和兼容性。

4. meta 标签有哪些常用属性？

   > [!NOTE]
   >
   > meta 标签是 HTML 中用于提供页面元数据的元素，通常放在 head 区域。它不直接显示在页面上，但对浏览器、搜索引擎和用户体验有重要影响。以下是前端面试中常见的 meta 标签属性及其作用：
   >
   > 1. charset 属性，用于指定文档的字符编码。常用值为 UTF-8，
   >
   >    <meta charset="UTF-8">
   >
   >    用途：确保浏览器正确解析文本，避免乱码。UTF-8 是现代 Web 开发的默认编码，支持多语言字符。
   >
   > 2. name 和 contetn 属性结合，用于定义文档的元数据，提供额外信息。常见用法 name=“viewport”，用于控制移动端视口行为，适配响应式设计。常用值为 width=device-width，initial-scale=1.0 。
   >
   >    <meta name="viewport" content="width=device-width, initial-scale=1.0">
   >
   >    其中 width=device-width 用于使页面宽度等于设备宽度，initial-scale=1.0 设置初始缩放比例为 1，这样确保在移动设备上正常显示，避免缩放问题。
   >
   >    name = “description” content=“这是一个什么什么页面”。用于搜索引擎显示在搜索结果摘要中，提升 SEO。
   >
   >    name=“keywords” content=“很多关键词 ... ”。用于指定页面关键词，提升 SEO 。
   >
   >    name=“author” content=“作者名字 ...“ 标记页面作者，记录开发者信息。
   >
   >    name=”robots“，用于控制搜索引擎的爬虫行为，常用值 index，follow，noindex（禁止页面被索引），nofollow（禁止爬虫跟踪页面链接）
   >
   > 3. http-equiv 和 content 属性结合，用于模拟 HTTP 响应头，控制浏览器的行为。常见的用法 `<meta http-equiv="refresh" content="5; url=targte_url">`，5 秒后跳转到指定的 URL。
   >
   >    `<meta http-equiv="X-UA-Compatible" content="IE=edge">` ，指定 ie 浏览器的渲染模式，强制 IE 使用最新引擎渲染，避免兼容模式。
   >
   > 4. property 属性，用于为社交媒体分享优化页面数据，提升页面在社交平台上的展示效果。
   >
   >    `<meta property="og:title" content="展示的标题">`
   >
   >    `<meta property="og:description" content="展示的描述">`
   >
   >    `<meta property="og:image" content="展示的图片">`
   >
   > 提到 viewport 在移动端开发的重要性，或 og: 属性在社交营销中的作用。强调 meta 标签必须放在 head 中，且内容应简洁有效。可以说说 CSP 相关的 meta 用法。

5. HTML 中的 data- 属性有什么用？

   > [!NOTE]
   >
   > 是 HTML5 引入的一种自定义属性（Custom Data Attributes），用于在 HTML 元素中存储私有或自定义的数据。这些数据不会影响元素的默认行为或样式，而是提供了一种标准化的方式，让开发者可以在标签中嵌入额外信息，并通过 JavaScript 或 CSS 访问和操作。核心作用是为 HTML 元素提供自定义数据的存储和访问方式，极大地方便了前端开发中的动态交互和逻辑处理。
   >
   > 允许开发者将任意键值对数据附加到 HTML 元素上，键名以 data- 开头，后接自定义名称。然后通过 JS 的 dataset 属性，可以获取和修改 data- 属性的值。其中在获取的时候，dataset 会将连字符转换为驼峰命名。
   >
   > 常用于动态交互逻辑，比如标记元素状态以及用作事件委托时的识别目标，存储配置信息或传递数据给脚本。也可以配合 CSS 的属性选择器来为元素设置样式。
   >
   > data- 是 W3C 的标准，合法且不会与未来的 HTML 冲突。其键值对完全由开发者定义，使用范围广，没有任何的副作用，不会影响 HTML 的语义和浏览器的默认行为。命名规范时小写字母、数字和连字符，避免特殊字符。虽然自定义数据很方便，但是不建议存储大量数据。还要避免存储敏感信息，因为它在 dom 中是可见的。

6. defer 和 async 在 <script> 中的区别是什么？

   > [!NOTE]
   >
   > script 标签的 defer 和 async 是两个用于优化外部脚本加载和执行的属性。它们解决了传统 script 标签阻塞 HTML 解析的问题，但在加载和执行时机上有显著区别。
   >
   > 默认情况下，浏览器在遇到 script 标签时会暂停 HTML 解析，下载脚本并立即执行，执行完毕后再继续解析 HTML。这时候，如果脚本文件较大或网络较慢，会阻塞页面渲染。
   >
   > 如果 script 携带了 defer 或者 async，都允许浏览器在下载脚本的同时继续解析 HTML，避免阻塞。但它们在脚本的 **执行时机** 和 **适用场景** 上不同。
   >
   > defer 是延迟执行，脚本会在 HTML 文档解析完成（即 DOM 构建完成，触发 DOMContentLoaded 事件前）后按照脚本在页面中的顺序执行。它能保证脚本的执行顺序与它们在 HTML 中的书写顺序一致。适用于需要依赖 DOM 元素或多个脚本之间有依赖关系的场景。
   >
   > async 是异步执行，脚本会在下载完成后立即执行，不等待 HTML 解析完成。它不保证脚本的执行顺序，哪个脚本先下载完成就先执行。适用于独立脚本（如统计分析工具、广告脚本），无需依赖 DOM 或其他脚本。
   >
   > 其次它们只适用于外部脚本，对于内联脚本无效。
   >
   > 如果同时指定了 defer 和 async，则是 async 优先。
   >
   > 表示了 type=“module” 的外部脚本默认带有 defer。但是可以通过设置 async 覆盖为异步执行。
   >
   > 它们是前端性能优化的重要手段，能较少页面白屏的时间。

   > [!IMPORTANT]
   >
   > #### **底部脚本的优点**
   >
   > 1. **简单直观**：无需额外属性，易于理解和实现。
   > 2. **兼容性强**：适用于所有浏览器，无需担心 defer/async 支持。
   > 3. **保证 DOM 可用**：天然适合 DOM 操作脚本。
   >
   > #### **底部脚本的缺点**
   >
   > 1. **串行加载**：多个脚本按顺序下载和执行，无法并行，效率低于 defer。
   > 2. **延迟执行**：脚本加载晚于页面内容，可能影响动态功能的初始化（如延迟加载交互逻辑）。
   >
   > #### **defer 和 async 的优势**
   >
   > - defer：并行下载 + 顺序执行，适合多脚本依赖场景。
   > - async：最快执行，适合独立脚本。
   > - **缺点**：需要浏览器支持（老版本 IE 可能不完全兼容）。

7. src 和 href 有什么区别？

   > [!NOTE]
   >
   > src 和 href 都是用于引用外部资源的属性，但它们的用途、适用标签以及行为有明显的区别。
   >
   > src 是 source 的简写，表示“资源来源”，用于指定嵌入到页面中的外部资源文件（如脚本、图片、视频等）。这些资源通常会被浏览器加载并替换或嵌入到当前元素的位置。嵌入的资源会被浏览器下载并处理，可能阻塞渲染。如 script img video audio iframe source
   >
   > href 是 Hypertext Reference 的简写，表示“超文本引用”，用于指定链接目标的地址，通常用于导航或关联外部资源（如网页、样式表等）。它不直接嵌入资源，而是建立一种引用关系，在用户交互（如点击）或浏览器处理时才会触发。如 a link
   >
   > 两者都支持相对路径、绝对路径或 URL。
   >
   > script 通过 src 加载并嵌入 JavaScript，适合功能逻辑，直接影响页面行为。
   >
   > link 通过 href 引用 CSS，适合样式控制，建立关联而不嵌入内容。
   >
   > **性能角度**：src 默认阻塞（可用 defer/async 优化），href 在 <link> 中异步加载。

8. 什么是 HTML 的 contenteditable 属性？

   > [!NOTE]
   >
   > 是 HTML5 引入的一个全局属性（Global Attribute），用于指定一个元素是否可以被用户编辑。当该属性被添加到元素上时，用户可以直接在页面上修改该元素的内容（如文本、图片等），类似于文本编辑器中的行为。它为前端开发提供了一种简单的方式来实现可编辑区域，无需复杂的 JavaScript 或第三方库。
   >
   > 属性值可以取 true、false、空值，空值等同于 true 表示元素内容可以编辑。如果父元素设置了为 true，则子元素默认继承为可编辑，除非子元素显式设置为 false。
   >
   > 允许用户在浏览器中直接编辑内容，无需额外的表单控件。通过 JavaScript 获取或设置编辑后的内容（如 innerHTML 或 textContent）。编辑后的内容仅存在于当前页面，刷新后丢失。
   >
   > 使用场景有简易的在线编辑器，交互式表单等。需处理兼容性、安全性、性能和持久化问题。

9. 如何实现图片懒加载？

   > [!NOTE]
   >
   > 图片懒加载（Lazy Loading）是一种前端优化技术，用于延迟加载页面中的图片，只有当图片进入或即将进入用户视口（可视区域）时才加载。这种方法可以减少初始页面加载时的资源请求，提升加载速度，节省带宽，尤其对图片较多或长页面非常有效。
   >
   > 原理是初始时不加载图片的真实地址（src），而是用占位符或空值替代。监听页面滚动或元素位置，当图片进入视口时动态设置 src，触发加载。
   >
   > 实现方式一般有三种：
   >
   > 1. 使用 js 手动实现。
   >
   >    ```html
   >    <html>
   >      <head>
   >        
   >      </head>
   >      <body>
   >        <img data-src="./img01" alt="img01" >
   >        <img data-src="./img02" alt="img02" >
   >        
   >        <script>
   >        // 获取图片 dom
   >        const lazyImages = document.querySelectorAll("img[data-src]");
   >          
   >        // 判断图片是否在视口中
   >        function isInViewPort(ele) {
   >          const rect = ele.getBoundingClientRect();
   >          return (rect.top >= 0 && rect.top <= (window.innerHeight || document.documentElement.clientHeight))
   >        }
   >        // 加载图片
   >        function loadImage(img) {
   >          if(img.dataset.src){
   >            img.src = img.dataset.src; // 设置真实地址
   >            img.removeAttribute("data-src"); // 加载后移除属性，避免重复处理。
   >          }
   >        }
   >          
   >        // 检查并加载可见图片
   >        function checkImages() {
   >          lazyImages.forEach(img => {
   >            if(isInViewPort(img)){
   >              loadImage(img);
   >            }
   >          }
   >        }
   >                             
   >        // 监听滚动和初次加载
   >        window.addEventListener("scroll", checkImages);
   >        window.addEventListener("resize", checkImages);
   >        // 页面加载时检查
   >        checkImages();
   >        </script>
   >      </body>
   >    </html>
   >    ```
   >
   >    使用节流优化
   >
   >    ```js
   >    function throttle(fn, delay = 150) {
   >      let timer;
   >      return function() {
   >        if(!timer){
   >          timer = setTimeout(() => {
   >            fu();
   >            timer = null;
   >          }, delay);
   >        }
   >      };
   >    };
   >    
   >    window.addEventListener('scroll', throttle(checkImages, 200));
   >    ```
   >
   > 2. 使用 IntersectionObserver api 监听元素是否进入视口。
   >
   >    ```javascript
   >    const images = document.querySeletorAll('img[data-src]');
   >                         
   >    const observer = new IntersectionObserver((entries, observer) => {
   >      entries.forEach(entry => {
   >        if(entry.isIntersecting){ // 元素进入视口
   >          const img = entry.target;
   >          img.src = img.dataset.src;
   >          img.removeAttribute('data-src');
   >          observer.unobserve(img); // 加载之后停止观察
   >        }
   >      })
   >    }, { rootMargin: '0px 0px 100px 0px'}); // 提前 100px 加载
   >                         
   >    images.forEach(img => observer.observe(img));
   >                         
   >    // 该方法不支持老旧浏览器，如 IE。
   >    ```
   >
   >    
   >
   > 3. 使用 HTML 原生的 loading 属性。设置 loading=“lazy”，浏览器自动延迟加载。
   >
   >    ```html
   >    <html>
   >      <body>
   >        <img src="imgsrc" loading="lazy" alt="懒加载图片" >
   >      </body>
   >    </html>
   >    ```
   >
   >    总结
   >
   >    在电商网站的长列表中，使用 IntersectionObserver 实现图片懒加载，提升首屏速度。
   >
   >    手动实现需节流避免性能瓶颈，IntersectionObserver 是现代最佳实践。
   >
   >    可以用低质量图片（如 base64 小图）作为 src，提升用户体验。
   >
   >    确保 alt 属性完善，懒加载不影响搜索引擎抓取。
   >
   >    **手动 JS**：灵活但需优化性能。
   >
   >    **Intersection Observer**：高效、现代，推荐使用。
   >
   >    **HTML loading**：最简单，但控制少。 根据项目需求选择方案（如兼容性要求用 JS，现代应用用 API），并结合占位图和节流技术，全面展示懒加载的实现思路。

10. iframe 的优缺点是什么？

    > [!NOTE]
    >
    > iframe 是 HTML 中的一个元素，用于在当前页面中嵌入另一个独立的 HTML 文档。
    >
    > 优点
    >
    > 1. 独立性强。嵌入的内容运行在独立的上下文中，与主页面互不干扰，包括 DOM、CSS 和 JavaScript。可以加载第三方内容（如广告、地图）而不影响主页面。
    > 2. 模块化加载。可以将页面拆分为多个独立的部分，按需加载。适合嵌入动态内容，如视频播放器、表单或外部工具。
    > 3. 并行加载。iframe 的资源加载与主页面并行，不阻塞主页面渲染。提升页面加载性能，尤其适合加载较慢的外部资源。
    > 4. 安全性。由于沙箱机制（sandbox 属性），可以限制嵌入内容的权限。防止恶意代码影响主页面。<iframe src="untrusted.html" sandbox="allow-scripts"></iframe>
    > 5. 跨域支持。可以嵌入不同域名下的页面，便于集成外部服务，如支付接口或社交媒体插件。
    >
    > 缺点
    >
    > 1. 性能开销。每个 iframe 创建一个独立的浏览上下文，增加内存和 CPU 使用。页面中多个 iframe 可能导致性能下降。
    > 2. SEO 不友好。搜索引擎难以抓取 iframe 内的内容，嵌入的关键内容可能无法被索引，影响页面排名。
    > 3. 交互的复杂性。主页面与 iframe 之间的通信受限（受同源策略限制），需要使用 postMessage 等方式实现跨文档通信，增加开发难度。
    > 4. 响应式设计困难。iframe 的宽高通常需要固定设置（如 width 和 height），难以自适应。在移动端可能出现滚动条或布局问题。
    > 5. 历史记录问题。iframe 内的页面导航会影响浏览器历史记录。用户点击返回键可能只退出 iframe 而非主页面，体验不一致。
    > 6. 安全风险。未正确配置（如未使用 sandbox）时，恶意 iframe 内容可能攻击主页面。如点击劫持（Clickjacking）。可设置 X-Frame-Options 或 CSP（Content Security Policy）。
    >
    > 总结：iframe 适合嵌入隔离内容，但不宜用于核心页面结构。

11. HTML 中的 title 属性有什么作用？

    > [!NOTE]
    >
    > title 属性是一个全局属性（Global Attribute），可以应用到几乎所有的 HTML 元素上。它的主要作用是提供关于元素的附加信息，通常以**工具提示（tooltip）**的形式显示，当用户将鼠标悬停在元素上时，浏览器会弹出一个小提示框展示 title 的内容。
    >
    > 主要作用
    >
    > 1. 提供补充说明。title 属性为元素添加描述性文本，帮助用户理解元素的功能、内容或上下文。
    > 2. 增强用户体验。通过简短的提示，减少用户对元素用途的疑惑，尤其在图标或缩写内容上。
    > 3. 提升可访问性。为屏幕阅读器提供额外信息，辅助视障用户理解页面内容。
    > 4. 不影响页面布局。title 的内容不会直接显示在页面上，仅在交互时出现，不占用空间。
    >
    > 使用场景
    >
    > 1. 按钮和链接的提示。
    > 2. 图标或图片的描述。
    > 3. 表单元素的补充。
    > 4. 解释专业术语或缩写。
    >
    > 注意事项
    >
    > 1. 显示时机。title 内容仅在鼠标悬停时显示，触摸设备（如手机）无法触发，移动端体验受限。
    > 2. 长度限制。过长的 title 可能被浏览器截断，建议简洁明了（一般不超过 60-80 个字符）。
    > 3. 与 alt 的区别。title 是用户交互时显示的提示，不强制。alt 是图片的替代文本，主要为可访问性和 SEO，强制性更强。
    > 4. 可访问性问题。并非所有屏幕阅读器可靠读取 title，不要将其作为唯一的信息来源。搭配 aria-label 或 aria-describedby。
    > 5. 样式不可控。title 提示的外观由浏览器决定，无法通过 CSS 自定义。

12. 如何禁用浏览器的默认表单提交行为？

    > [!NOTE]
    >
    > 表单默认提交行为是当用户点击提交按钮（如 <button type="submit">）或按下回车键时，浏览器会将表单数据发送到 action 属性指定的 URL，并刷新页面或跳转。
    >
    > 如何阻止
    >
    > 1. 使用 event.preventDefault()。在表单的 submit 事件监听器中调用 event.preventDefault()，阻止默认提交行为。灵活性高，可以自定义提交后的逻辑。
    > 2. 按钮上使用 event.preventDefault()。在提交按钮的 click 事件中阻止默认行为。适用于只针对按钮触发的提交。操作更直接，但无法阻止回车键触发的提交，需额外监听表单的 submit 事件。
    > 3. 使用 onsubmit 返回 false。在 <form> 标签的 onsubmit 属性中返回 false，阻止默认提交。
    > 4. 设置按钮 type="button"。将提交按钮的 type 从 submit 改为 button，使其不触发表单提交。然后手动处理点击逻辑。这会失去回车提交的便捷性，需额外处理键盘事件。
    > 5. 禁用表单提交（Vue/React 示例）。在 vue 中，可以直接在 form 元素上监听 submit 事件，并附带上 prevent 修饰符。@submit.prevent 是 Vue 的语法糖，等价于 event.preventDefault()。
    >
    > 使用场景
    >
    > 阻止提交，验证输入后再决定是否发送请求，用户名为空时阻止提交并提示。用 fetch 或 axios 发送数据，避免页面刷新。可以保持单页面应用的状态，禁止跳转。

13. link 和 @import 的区别是什么？

    > [!NOTE]
    >
    > link 和 @import 都是用于引入外部 CSS 文件的方法，但它们的使用方式、加载机制和适用场景有显著差异。
    >
    > 差异
    >
    > 1. link 是 HTML 标签，写在 <head> 中，用于引入外部资源（如 CSS）。@import 是 CSS 规则，用于在 CSS 文件或 <style> 标签中引入其他 CSS 文件，且必须在 CSS 文件的开头，或 <style> 内的第一行。
    > 2. 加载机制。浏览器解析 HTML 时，遇到 <link> 会立即并行下载 CSS 文件，不阻塞 HTML 解析，CSS 下载完成后立即应用到页面。浏览器解析到 @import 时，才发起对目标 CSS 文件的请求，加载是串行的，主 CSS 文件下载并解析后，才开始加载 @import 的文件，可能延迟样式应用，如果嵌套多层 @import，会逐层串行加载。
    > 3. 性能影响。link 并行加载，减少页面渲染阻塞时间。@import 串行加载，可能增加加载时间。
    > 4. 适用场景。link 是主流方式，用于页面级 CSS 引入，支持动态加载，可指定 media 属性控制条件加载，用于项目中加载核心样式表。@import 用于 CSS 内部管理模块化样式，可以在 CSS 中动态引入其他样式，便于组织，支持条件引入（如媒体查询），用于将多个 CSS 文件组合为一个逻辑单元。
    > 5. 动态操作。link 可以通过 JavaScript 动态添加或移除。@import 无法通过 JavaScript 动态修改，只能静态定义在 CSS 中。
    > 6. 浏览器支持和限制。link 所有浏览器广泛支持，无明显限制。@import 老旧浏览器（如 IE5）对嵌套层数有限制，且必须放在 CSS 开头，否则无效。
    > 7. SEO 和维护性。link 直接在 HTML 中可见，便于搜索引擎解析，样式引用集中于 <head>，易于管理。@import 隐藏在 CSS 中，不利于抓取，分散在 CSS 文件中，复杂项目中可能难以维护。

14. HTML 中的 alt 属性有什么作用？

    > [!NOTE]
    >
    > alt 属性是 HTML 中用于 <img> 标签（以及 <area> 标签）的属性，全称是 **"alternative text"（替代文本）**。它的主要作用是为图片提供文本描述，在特定场景下替代图片内容。
    >
    > 主要作用
    >
    > 1. 提供可访问性（Accessibility)。为屏幕阅读器（如 NVDA、JAWS）提供图片的文本描述，帮助视障用户理解图片内容。
    > 2. 图片加载失败时的替代显示。当图片因网络问题、路径错误或格式不支持而无法加载时，浏览器会显示 alt 文本。可避免用户面对空白或错误，提升体验。
    > 3. 搜索引擎优化（SEO）。搜索引擎（如 Google）无法直接解析图片内容，依赖 alt 文本判断图片含义。可提高图片搜索排名和页面曝光率。
    > 4. 上下文补充。为用户提供图片的背景信息，即使图片可见也能增加理解。
    >
    > 使用场景
    >
    > 1. 装饰性图片。如果图片仅用于美化，不含实质信息，alt 可设为空值（alt=""）。
    > 2. 功能性图片。如果图片有交互作用（如按钮图标），alt 应描述其功能。
    > 3. 内容性图片。如果图片是页面核心内容，alt 应详细描述。
    >
    > 与 title 的区别
    >
    > alt 是转为 img 标签设计，用于辅助和替代图片内容。用于可访问性，SEO或者加载失败。不以工具提示形式显示。
    >
    > title 是全局属性，鼠标悬停时显示。用于补充信息，不强制。
    >
    > 其中 HTML 规范要求 img 标签必须要有 alt 属性，即使为空。

15. 什么是 HTML 的 manifest 属性？

    > [!NOTE]
    >
    > manifest 属性是 HTML5 中引入的一个属性，通常用于 <html> 标签，它指定了一个 **应用程序缓存清单（Application Cache Manifest）** 文件的地址。这个文件定义了网页在离线状态下可以缓存的资源，从而支持离线访问。然而，需要注意的是，manifest 属性和与之相关的 **HTML5 Application Cache（AppCache）** 已被 W3C 标记为**废弃（deprecated）**，推荐使用更现代的 **Service Workers** 替代。
    >
    > 基本作用
    >
    > manifest 属性指向一个 .appcache 文件（通常以 .appcache 为扩展名），该文件列出了浏览器应缓存的资源（如 HTML、CSS、JS、图片等），以便在无网络连接时仍能访问页面。用于实现网页的离线功能，常见于早期的移动 Web 应用或需要离线支持的场景。主要为早期的 web 应用在网络不稳定的环境下提供离线访问，用于缓存静态资源，减少带宽使用。
    >
    > <html manifest="manifest.appcache">
    >
    > 工作原理
    >
    > manifest 文件是一个纯文本文件。分为三个主要部分 CACHE（指定需要缓存的资源）、NETWORK（指定始终需要网络访问的资源）、FALLBACK（指定离线时的回退资源）。必须以 CACHE MANIFEST 开头。服务器必须将 .appcache 文件的 MIME 类型设置为 text/cache-manifest，否则浏览器无法识别。
    >
    > ```html
    > <!DOCTYPE html>
    > <html manifest="demo.appcache">
    > <head>
    >   <title>离线应用</title>
    > </head>
    > <body>
    >   <h1>欢迎</h1>
    >   <img src="logo.png" alt="标志">
    > </body>
    > </html>
    > ```
    >
    > ```shell
    > # demo.appcache 文件
    > CACHE MANIFEST
    > # 版本 1.0
    > 
    > CACHE:
    > index.html
    > styles.css
    > script.js
    > logo.png
    > 
    > NETWORK:
    > /api/*
    > 
    > # 网络不可用时，用 offline.html 替代。
    > FALLBACK:
    > / offline.html
    > ```
    >
    > 缓存流程
    >
    > 浏览器首次加载页面时，下载 manifest 文件并缓存指定资源。离线时，浏览器使用缓存资源渲染页面。当 manifest 文件更新时，浏览器重新缓存资源。
    >
    > 优点
    >
    > 离线支持、减少请求、简单实现
    >
    > 缺点
    >
    > 更新困难、不可控性(缓存管理不灵活，无法动态清除或部分更新)、调试复杂（缓存问题难以排查）、性能问题（首次加载需下载所有资源，可能增加初始加载时间）
    >
    > 替代方案
    >
    > 使用 Service Workers 替代。Service Workers 可以更加细腻的控制缓存，可拦截和缓存特定请求。用 js 控制，支持动态更新。灵活性高，支持复杂逻辑。是现代 web 标准，浏览器广泛支持。
    >
    > ```js
    > // service-worker.js
    > self.addEventListener('install', (event) => {
    >   event.waitUntil(
    >     caches.open('v1').then((cache) => {
    >       return cache.addAll([
    >         '/',
    >         '/styles.css',
    >         '/script.js',
    >       ]);
    >     })
    >   );
    > });
    > 
    > self.addEventListener('fetch', (event) => {
    >   event.respondWith(
    >     caches.match(event.request).then((response) => {
    >       return response || fetch(event.request);
    >     })
    >   );
    > });
    > ```
    >
    > ```html
    > <script>
    >   if ('serviceWorker' in navigator) {
    >     navigator.serviceWorker.register('/service-worker.js');
    >   }
    > </script>
    > ```

16. 如何在 HTML 中嵌入 SVG？

    > [!NOTE]
    >
    > SVG（Scalable Vector Graphics，可伸缩矢量图形）是一种基于 XML 的矢量图像格式，广泛用于网页中的图标、图表和动画。
    >
    > 使用方式
    >
    > 1. 使用 <img> 标签，将 SVG 文件作为外部资源通过 <img> 的 src 属性引入。
    >
    >    ```html
    >    <img src="icon.svg" alt="图标">
    >    ```
    >
    >    具有简单易用，类似普通图片（如 PNG）、支持缓存和复用、加载性能好的优点。但无法通过 CSS 或 JavaScript 直接操作 SVG 内部元素（如修改颜色），不支持动画或交互。
    >
    > 2. 使用 <object> 标签嵌入外部 SVG 文件。
    >
    >    ```html
    >    <object type="image/svg+xml" data="chart.svg" width="300" height="200">
    >      您的浏览器不支持 SVG
    >    </object>
    >    ```
    >
    >    具有支持独立的 SVG 文档（包括脚本和动画）、可通过 JavaScript 访问 SVG DOM（需跨域允许）、可提供回退内容。但是比较复杂，CSS 样式隔离，难以直接影响内部元素。
    >
    > 3. 使用 <iframe> 标签将 SVG 文件嵌入到 <iframe> 中。
    >
    >    ```html
    >    <iframe src="logo.svg" width="100" height="100" frameborder="0"></iframe>
    >    ```
    >
    >    具有完全隔离 SVG 内容，适合复杂的独立文件、支持动画和脚本的优点。但性能开销较大，难以与主页面交互或样式化。
    >
    > 4. 内联 SVG（直接写入 <svg> 标签）将 SVG 代码直接写入 HTML。
    >
    >    ```html
    >    <svg width="100" height="100" viewBox="0 0 100 100">
    >      <circle cx="50" cy="50" r="40" fill="red" />
    >      <text x="50" y="55" text-anchor="middle" fill="white">SVG</text>
    >    </svg>
    >    ```
    >
    >    具有可控性强，可直接用 CSS 样式化 SVG 内部的元素（如 fill，stroke）、动态交互，可通过 JS 操作 SVG DOM、无额外请求，减少网络开销。直接签入会增加 HTML 文件的大小，且不便于复用。
    >
    >    ```css
    >    circle {
    >      fill: blue;
    >    }
    >    ```
    >
    >    ```js
    >    document.querySelector('circle').setAttribute('r', '30');
    >    ```
    >
    > 5. 使用 CSS background-image 将 SVG 文件作为背景图引入。具有简单、支持复用和缓存的优点，但是无法操作 SVG 内部元素，不支持动画。
    >
    >    ```js
    >    <div class="icon"></div>
    >    <style>
    >      .icon {
    >        width: 50px;
    >        height: 50px;
    >        background-image: url('icon.svg');
    >        background-size: contain;
    >      }
    >    </style>
    >    ```
    >
    > 6. 使用 <use> 引用 SVG 片段，将 SVG 定义在 <defs> 中，通过 <use> 复用。
    >
    >    ```html
    >    <svg style="display: none;">
    >      <defs>
    >        <symbol id="star" viewBox="0 0 100 100">
    >          <polygon points="50,0 61,35 98,35 68,57 79,91 50,70 21,91 32,57 2,35 39,35" fill="yellow"/>
    >        </symbol>
    >      </defs>
    >    </svg>
    >    <svg width="50" height="50">
    >      <use href="#star" />
    >    </svg>
    >    <svg width="30" height="30">
    >      <use href="#star" />
    >    </svg>
    >    ```
    >
    >    具有复用性强，一个定义多处使用、可通过 CSS 和 JS 控制的优点，但是需内联定义，增加代码量，外部 SVG 文件需通过其他方式引入。
    >
    >    性能优化
    >
    >    1. 内联 SVG 或 <use> 避免额外 HTTP 请求
    >
    >    2. 使用工具（如 SVGO）优化 SVG 文件大小
    >
    >    3. 对外部 SVG（如 <img>）使用 loading="lazy"
    >
    >    4. 内联 SVG 可通过 viewBox 自适应，
    >
    >       ```html
    >       <svg viewBox="0 0 100 100" width="100%">
    >         <rect x="10" y="10" width="80" height="80" fill="green"/>
    >       </svg>
    >       ```

17. HTML 中的 hidden 属性有什么用？

    > [!NOTE]
    >
    > hidden 属性是 HTML5 引入的一个全局属性（Global Attribute），可以应用到任何 HTML 元素上。它的作用是**隐藏元素**，使元素在页面上不可见，同时从布局中移除，类似于 CSS 的 display: none。
    >
    > 当元素设置 hidden 属性时，浏览器不会渲染该元素，用户无法看到或交互。hidden 是一个布尔属性，存在即生效（hidden 或 hidden=""），不存在或设为 hidden="false" 表示不隐藏。
    >
    > 主要作用
    >
    > 1. 控制元素可见性，快速隐藏元素，无需编写额外的 CSS。
    > 2. 语义化标记，通过 HTML 属性明确表示元素应隐藏，具有语义化意义。
    > 3. 动态显示/隐藏，结合 JavaScript 动态切换元素的可见性。可访问性支持，隐藏的元素会被屏幕阅读器忽略，提升无障碍体验。
    >
    > 应用场景
    >
    > 1. 用于页面加载时默认隐藏的元素
    > 2. 在前端框架中结合逻辑控制条件显示
    > 3. 表单提示中隐藏错误信息，动态显示
    > 4. 用于逐步加载，隐藏未就绪的内容，加载完成后再显示
    >
    > hidden 是 HTML5 属性，现代浏览器广泛支持，老旧浏览器（如 IE9 以下）需 polyfill 或用 display: none 替代。hidden 自动映射到 aria-hidden="true"，但显式设置 aria-hidden="false" 会覆盖。
    >
    > 以下是以表格形式列出的 `hidden` 属性、`display: none` 和 `visibility: hidden` 的详细对比，清晰简洁，适合前端面试场景展示。
    >
    > | **特性**     | **`hidden`**                    | **`display: none`**                      | **`visibility: hidden`**                        |
    > | ------------ | ------------------------------- | ---------------------------------------- | ----------------------------------------------- |
    > | **定义**     | HTML5 全局属性                  | CSS 属性                                 | CSS 属性                                        |
    > | **用法示例** | `<div hidden>内容</div>`        | `<div style="display: none;">内容</div>` | `<div style="visibility: hidden;">内容</div>`   |
    > | **隐藏效果** | 完全隐藏，不渲染                | 完全隐藏，不渲染                         | 隐藏但保留布局                                  |
    > | **占用空间** | 否                              | 否                                       | 是                                              |
    > | **默认行为** | 等同 `display: none`            | 移除元素渲染                             | 元素不可见但保留空间                            |
    > | **语义性**   | 有（表示“应隐藏”）              | 无（纯样式）                             | 无（纯样式）                                    |
    > | **优先级**   | 可被 CSS `display` 覆盖         | 覆盖 `hidden`                            | 与 `display` 无冲突                             |
    > | **可访问性** | 映射 `aria-hidden="true"`，忽略 | 屏幕阅读器忽略                           | 可能被读取，需 `aria-hidden`                    |
    > | **JS 操作**  | `element.hidden = true/false`   | `element.style.display = 'none'/'block'` | `element.style.visibility = 'hidden'/'visible'` |
    > | **性能影响** | 不渲染，节省资源                | 不渲染，节省资源                         | 参与布局，略高开销                              |
    > | **继承性**   | 不继承，子元素默认可见          | 子元素随父移除                           | 可继承，子元素可覆盖                            |
    > | **动画支持** | 否（直接移除）                  | 否（直接移除）                           | 是（支持过渡效果）                              |
    > | **使用场景** | 语义化隐藏、动态切换            | 条件渲染、完全移除                       | 占位隐藏、动画效果                              |
    >
    > ---
    >
    > 示例代码
    >
    > ```html
    > <div hidden>hidden 隐藏</div>
    > <div style="display: none;">display: none 隐藏</div>
    > <div style="visibility: hidden;">visibility: hidden 隐藏</div>
    > <div>可见内容</div>
    > ```
    > - **效果**：
    >   - `hidden` 和 `display: none`：不显示，不占空间。
    >   - `visibility: hidden`：不显示，但留空白。
    >
    > ---
    >
    > 总结
    >
    > - **`hidden`**：语义化，简单切换，类似 `display: none`。
    > - **`display: none`**：完全移除，性能优，适合条件渲染。
    > - **`visibility: hidden`**：占位隐藏，支持动画，适合保留布局。

18. 什么是 HTML 的 preload 和 prefetch？

    > [!NOTE]
    >
    > preload 和 prefetch 是 HTML 中用于优化资源加载的机制，通常通过 <link> 标签实现。它们帮助浏览器提前加载关键资源或预测用户可能需要的资源，从而提升页面性能和用户体验。
    >
    > preload（预加载）是一种资源预加载指令，告诉浏览器**尽快加载当前页面必需的关键资源**，以便在需要时立即可用，通过 <link rel="preload"> 定义。主要用于提前加载对页面渲染或功能至关重要的资源（如 CSS、JS、字体、图片等），减少等待时间，它不会阻塞页面渲染，而是并行加载。一个完整的 preload 指令需要三个属性，rel = preload、as = style | script | image | font、href = 资源地址。可用于提升首屏渲染速度，确保关键资源优先级高于非关键资源。需要正确设置 as 属性，否则可能被忽略，避免重复预加载浪费带宽。
    >
    > prefetch（预取）是一种资源预取指令，告诉浏览器在空闲时加载**用户未来可能需要的资源**，通常用于下一页或后续导航，通过 <link rel="prefetch"> 定义。主要作用是在当前页面加载完成后，利用空闲带宽提前加载预测资源，优化后续页面访问速度。它不保证立即加载，优先级低于 preload。不需要 as 属性。可用于优化导航体验，减少跳转等待时间，利用空闲资源，不影响当前页面，它的优先级低，可能不会执行（视网络和浏览器策略）。
    >
    > preload 可用于提前加载字体，从而解决字体闪烁（FOUT），可用于提前加载关键资源，提升 LCP（Largest Contentful Paint）。
    >
    > prefetch 可以在空闲时加载非关键资源，优化 TTI（Time to Interactive），可以结合用户行为预测，如鼠标悬停的时候手动插入一个需要 prefetch 的资源。

19. HTML 中的 form 标签有哪些新特性？

    > [!NOTE]
    >
    > HTML5 为 <form> 标签及其相关元素引入了许多新特性和属性，增强了表单的功能性、可访问性和用户体验。这些新特性减少了对 JavaScript 的依赖，使表单验证、输入类型和交互更加原生化。
    >
    > HTML5 扩展了 <input> 元素的 type 属性，提供了更多语义化和功能化的输入类型，支持原生验证和键盘适配。如 email、url、tel、number、range、date、time、datetime-local、month、week、color、search。
    >
    > HTML5 为 <form> 和表单元素引入了新的属性，增强了控制和验证能力。如 autocomplete、novalidate、form、required、pattern、placeholder、autofocus、multiple、min、max、step、formaction、formenctype、formmethod、formtarget。
    >
    > HTML5 引入了新的表单相关标签，扩展了功能。如 datalist（为 <input> 提供自动补全选项列表）、output（显示计算或表单处理结果）、progress（显示任务进度条）、meter（显示范围内的测量值（如百分比））。
    >
    > 表单验证增强。required、pattern 等属性触发浏览器内置验证，可使用 setCustomValidity() API 自定义提示。
    >
    > ```html
    > <input type="text" id="input" pattern="[0-9]+" oninput="validate(this)">
    > <script>
    >   function validate(input) {
    >     input.setCustomValidity(input.value.match(/[0-9]+/) ? '' : '请输入数字');
    >   }
    > </script>
    > ```

20. 如何实现一个可访问性（Accessibility）友好的页面？

    > [!NOTE]
    >
    > 实现一个可访问性（Accessibility，简称 A11y）友好的页面，意味着确保所有用户（包括残障人士，如视障、听障、运动障碍用户）都能有效地访问和使用网页内容。这需要遵循 Web 无障碍标准。
    >
    > 1. 使用正确的语义标签提供结构和含义，便于屏幕阅读器理解页面。避免滥用 <div>，为内容赋予语义。
    > 2. 确保所有交互元素（如链接、按钮、表单）可通过键盘访问，服务无法使用鼠标的用户。确保元素可聚焦（默认或通过 tabindex）。避免破坏默认焦点顺序。添加键盘事件（如 Enter 或 Space 触发按钮）。
    > 3. 使用 ARIA 角色（role）和属性（如 aria-label、aria-hidden）。增强动态内容和复杂组件的可访问性，补充 HTML 语义。
    > 4. 为非文本内容提供替代描述。为 <img> 添加 alt 属性。使用 track 标签为视频/音频添加字幕或描述。
    > 5. 确保表单易于填写和理解。使用 <label> 关联输入、添加错误提示、使用 autocomplete 和 placeholder 辅助。
    > 6. 确保视觉内容对色盲或低视力用户友好，满足 WCAG 对比度要求（文本对比度至少 4.5:1），避免仅靠颜色传达信息。
    > 7. 使用相对单位（如 rem、em）适配不同设备和视力需求。避免固定高度，确保内容可缩放，支持浏览器缩放。
    > 8. 确保动态更新对所有用户可见，使用 aria-live 通知变化。
    > 9. 验证页面是否符合无障碍标准。在 Chrome DevTools 中运行 Lighthouse，检查 Accessibility 分数。
    >
    > ```html
    > <!DOCTYPE html>
    > <html lang="zh">
    > <head>
    >   <meta charset="UTF-8">
    >   <title>无障碍页面</title>
    >   <style>
    >     :focus { outline: 2px solid #0078d4; }
    >     .error { color: #d32f2f; }
    >     body { font-size: 1rem; color: #333; background: #fff; }
    >   </style>
    > </head>
    > <body>
    >   <header>
    >     <h1>欢迎</h1>
    >     <nav aria-label="主导航">
    >       <ul>
    >         <li><a href="#home">首页</a></li>
    >         <li><a href="#contact">联系</a></li>
    >       </ul>
    >     </nav>
    >   </header>
    >   <main>
    >     <form>
    >       <label for="email">邮箱：</label>
    >       <input id="email" type="email" required autocomplete="email" placeholder="请输入邮箱">
    >       <span id="email-error" role="alert" hidden>邮箱格式错误</span>
    >       <button type="submit">提交</button>
    >     </form>
    >     <img src="banner.jpg" alt="网站横幅，展示风景">
    >   </main>
    >   <script>
    >     document.querySelector('form').addEventListener('submit', (e) => {
    >       e.preventDefault();
    >       const email = document.getElementById('email');
    >       if (!email.checkValidity()) {
    >         document.getElementById('email-error').hidden = false;
    >       }
    >     });
    >   </script>
    > </body>
    > </html>
    > ```

    ## css

21. CSS 中的盒模型是什么？

    CSS 中的**盒模型（Box Model）**是 CSS 布局的基础概念，用于描述 HTML 元素在页面中如何渲染和占用空间。每一个元素都被视为一个矩形“盒子”，这个盒子由内容（content）、内边距（padding）、边框（border）和外边距（margin）组成。

    CSS 中有两种盒模型，区别在于如何计算元素的总宽高。

    第一种叫做标准盒模型。box-sizing 的值为 content-box，标准和模型是默认模型，width 和 height 只包含内容区域，不包括 padding 和 border。

    第二种叫做替代盒模型。通过 box-sizing: border-box 启用，width 和 height 包含内容、内边距和边框。

    常见问题：

    1. 外边距折叠，垂直相邻的 margin 会合并，取较大值。可使用 padding 或 flex/grid 布局解决此问题。
    2. 宽度溢出。在标准模型中，添加 padding 和 border 可能导致溢出父容器，可使用替代盒模型解决，即设置 box-sizing 为 border-box。

    早期 IE 使用替代模型，W3C 推广标准模型，box-sizing 统一了两者。盒模型影响重排（reflow），合理设置减少计算。

22. CSS 中的 display 属性有哪些常用值？

    display 属性是 CSS 中控制元素布局和渲染行为的核心属性之一，它定义了元素在页面中的显示方式和盒模型类型。

    | 值           | 描述                                                         | 用途                     |
    | ------------ | ------------------------------------------------------------ | ------------------------ |
    | block        | 元素作为块级元素，独占一行，从上到下排列。默认宽 100%，支持设置宽高、内外边距。 | 段落、标题、容器布局     |
    | inline       | 元素作为行内元素，不换行，与其他内容同行。设置宽高无效。不支持垂直 margin。 | 文本、链接、小图标       |
    | inline-block | 行内块元素，保持行内特性但可设置宽高。结合上面两者优点，支持布局调整。 | 按钮、图片排列           |
    | none         | 元素完全隐藏，不渲染，不占空间。节省资源。                   | 条件隐藏、动态显示       |
    | flex         | 启用弹性盒布局，子元素按弹性规则排列。                       | 响应式布局、居中、等分列 |
    | inline-flex  | 弹性盒的行内版本，不独占一行。                               | 小型弹性布局             |
    | grid         | 启用网格布局，支持二维排列。                                 | 复杂网格、杂志式布局     |
    | inline-grid  | 网格的行内版本，不独占一行。                                 | 小型网格布局             |
    | table        | 元素作为表格显示，类似 <table>                               | 模拟表格布局             |
    | table-row    | 元素作为表格行，类似 <tr>。                                  | 表格行排列               |
    | table-cell   | 元素作为表格单元格，类似 <td>。                              | 垂直居中、列布局         |
    | list-item    | 元素作为列表项，带标记（如圆点）。                           | 自定义列表样式           |
    | contents     | 元素自身不渲染，但子元素正常显示。                           | 调整层级结构             |

23. 如何实现水平居中？

    ```css
    // 1. 块级元素居中，使用 margin: auto
    // 简单，兼容性好。需要明确宽度，父容器宽度需大于子元素。
    .box {
        width: 200px;
        margin: 0 auto;
    }
    
    // 2. 块级元素居中，使用 Flexbox。父元素设置 display: flex; 和 justify-content: center
    // 无需固定宽度，灵活性高,可同时垂直居中（加 align-items: center）。
    .container {
        display: flex;
        justify-content: center;
    }
    
    // 3. 块级元素居中，使用 gird，父元素设置 display: grid，然后使用 justify-content: center 或者 justify-items: center
    .container {
        display: grid;
        justify-content: center;
    }
    
    // 4. 行内或行内块元素居中，使用 text-align
    // 适用于行内元素（如 span）或 inline-block 元素，父元素设置 text-align: center，子元素为 inline 或 inline-block。
    .parent {
        text-align: center;
    }
    .child {
        display: inline; // inline-block
    }
    
    // 5. 绝对定位居中，使用 absolute + left + transform
    // 适用于任何元素，需脱离文档流
    // 父元素设置 position: relative
    // 无需固定宽度，动画友好, 父容器需 position: relative 或其他非 static 值
    // 在子元素的宽度固定的情况下，也可以不使用 left + transform 而使用 width + left：0 + right：0 + margin：0 auto
    .parent {
        position: relative;
    }
    .child {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
    }
    ```

24. 如何实现垂直居中？

    ```css
    // 1. 块级元素定位使用绝对定位 + transform
    // 父容器需非 static 定位。子元素设置position: absolute 和 top: 50%; transform: translateY(-50%)
    // 如果子元素高度固定，也可以使用 top:0 + bottom:0 + margin: auto 0;
    .parent {
        position: relative;
    }
    
    .child {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
    }
    
    // 2. 块级元素垂直居中，使用 display: flex
    // 父元素设置弹性盒 + align-item: center, 多子元素可用 align-self 单独调整。
    .container {
        display: flex;
        align-item: center;
    }
    
    // 3. 块级元素居中使用 grid，父元素设置 display: grid 和 align-content: center
    .container {
        display: grid;
        align-content: center;
    }
    
    // 4. 模拟表格布局，适用于块级元素
    // 父元素设置 display: table; 子元素设置 display: table-cell 和 vertical-align: middle;
    .container {
        display: table;
    }
    .child {
        display: table-cell;
        vertical-align: middle;
    }
    
    // 5. 行内元素居中，使用 line-height，适用于单行文本或行内元素
    // 父元素设置 height 和相等的 line-height
    ```

25. CSS 中的 position 属性有哪些值？

    position 属性是 CSS 中用于控制元素定位方式的核心属性，它决定了元素在页面中的定位行为以及相对于何处进行定位。其中**偏移属性**：top、right、bottom、left 用于调整位置，仅对非 static 值生效。

    **层叠顺序**：搭配 z-index 控制重叠（如 absolute 和 fixed）。

    **性能**：absolute 和 fixed 不触发重排，适合动画。

    | **值**   | **脱离文档流** | **定位参考**        | **占用空间** | **滚动行为**     | **常见用途**     |
    | -------- | -------------- | ------------------- | ------------ | ---------------- | ---------------- |
    | static   | 否             | 文档流              | 是           | 随页面滚动       | 默认布局         |
    | relative | 否             | 自身原始位置        | 是           | 随页面滚动       | 微调、定位参考   |
    | absolute | 是             | 非 static 祖先/视口 | 否           | 随页面滚动       | 弹窗、覆盖层     |
    | fixed    | 是             | 视口                | 否           | 固定不动         | 导航栏、浮动按钮 |
    | sticky   | 否             | 滚动祖先/视口       | 是           | 滚动到阈值时固定 | 粘性标题、侧边栏 |

26. 什么是 BFC？如何触发？

    **BFC（Block Formatting Context，块级格式化上下文）** 是 CSS 中布局的一个重要概念，它定义了一个独立的渲染区域，其中的元素按照特定规则布局，与外部元素隔离。BFC 是 Web 页面中盒模型布局的一部分，影响元素的位置、间距和清除浮动等行为。BFC 不是默认状态，需要通过特定的 CSS 属性触发。

    | **触发方式**          | CSS 属性值                       | 说明                                                    |
    | --------------------- | -------------------------------- | ------------------------------------------------------- |
    | 根元素                |                                  | <html> 默认是 BFC，无需额外设置。                       |
    | 浮动元素              | float: left / right              | 浮动元素自动形成 BFC。                                  |
    | 绝对定位元素          | position: absolute / fixed       | 脱离文档流的元素形成 BFC。                              |
    | overflow 不为 visible | overflow: hidden / auto / scroll | 最常用，改变溢出行为触发 BFC。                          |
    | display 的流布局值    | display: flow-root               | HTML5 新值，专为触发 BFC 设计。                         |
    | 弹性布局或网格        | display: flex / grid             | 现代布局方式也会创建类似上下文（严格说是 FFC 或 GFC）。 |

    display: flex 和 grid 严格来说创建的是不同的格式化上下文（FFC 或 GFC），但行为上与 BFC 类似，常被归入广义讨论。

    BFC 的作用

    ```html
    // 1. 清除浮动（高度塌陷）。浮动子元素导致父元素高度塌陷，使用父元素触发 BFC 来解决。
    <div class="container">
      <div class="float">浮动</div>
    </div>
    <style>
      .float {
        float: left;
        width: 100px;
        height: 100px;
        background: lightblue;
      }
      .container {
        overflow: hidden; /* 触发 BFC */
        background: lightgray;
      }
    </style>
    
    // 2. 防止外边距折叠。相邻块级元素的垂直 margin 会合并，将元素放入不同 BFC，隔离折叠。
    <div class="bfc">
      <div class="box">上</div>
    </div>
    <div class="bfc">
      <div class="box">下</div>
    </div>
    <style>
      .box {
        margin: 20px;
        background: lightgreen;
      }
      .bfc {
        overflow: hidden; /* 触发 BFC */
      }
    </style>
    
    // 3. 隔离布局。浮动元素影响外部布局，使用 BFC 内部元素不影响外部方式可解决。
    <div class="float">浮动</div>
    <div class="bfc">BFC 内容</div>
    <style>
      .float {
        float: left;
        width: 100px;
        height: 100px;
        background: lightcoral;
      }
      .bfc {
        overflow: hidden; /* 触发 BFC */
        background: lightyellow;
      }
    </style>
    ```

    overflow: hidden 可能裁剪溢出内容，float 或 position: absolute 会改变元素布局，display: flex 和 grid 更常用，BFC 在传统布局中更常见。它早期用于解决浮动问题，现多被现代布局替代。

27. CSS 中的 float 属性有什么作用？

    float 属性是 CSS 中用于布局的传统属性之一，最初设计用于实现文字环绕图片的效果（如杂志排版），后来被广泛应用于创建多列布局。float 会改变元素的定位方式，使其脱离正常文档流，并在特定方向“浮动”。

    float 的基本作用是使元素向左或向右浮动，后续的文档流内容会围绕它排列。默认值是 none，表示不浮动，常用值是 left 和 right，分别是元素向左和向右浮动。

    核心作用是元素脱离正常文档流，但仍影响布局，浮动后紧贴容器边缘或前一个浮动元素，非浮动内容（如文本）环绕浮动元素。

    浮动元素自动形成块级格式化上下文（BFC）。浮动元素脱离文档流，父元素无法感知其高度，导致高度塌陷。通过清除浮动（clear 属性）在浮动后的元素上设置 clear: left/right/both 或触发父元素 BFC （父元素设置 overflow: hidden）或者使用父元素的伪元素清除浮动可解决。

28. CSS 选择器优先级如何计算？

    CSS 选择器优先级（也称为**特异性，Specificity**）决定了当多个样式规则同时作用于同一个元素时，哪条规则最终生效。优先级通过一种计算规则来确定，避免样式冲突。它通过一个四位数的权重值来表示，格式为 **[内联样式, ID, 类/属性/伪类, 标签]**，每一部分的权重从左到右递减。计算方法是统计选择器中每个类型的数量，按权重累加，组成 [a, b, c, d]，从左到右比较，数值大的优先级高。当优先级相同时，后定义的样式覆盖先定义的。其中通配符的权重为 0，仅影响匹配元素。

    权重不是简单的加法，而是分级（如 [0, 1, 0, 0] > [0, 0, 10, 10]），避免过度嵌套选择器，减少优先级冲突；优先级高时谨慎使用 !important。

29. 什么是 CSS 的 z-index？

    z-index 是 CSS 中的一个属性，用于控制元素在页面**叠放顺序（z轴方向）\**上的层级，适用于\**定位元素**（即 position 为 relative、absolute、fixed 或 sticky 的元素）。它决定了当元素重叠时，哪个元素显示在上方，哪个在下方。

    z-index 指定元素的堆叠顺序，值越大，元素越靠前（靠近用户）；值越小，越靠后。默认值为 auto，即不指定层级，按文档流或父元素顺序排列。只对非 position：static 的元素生效，在同一个堆叠上下文中比较。

    主要应用于使弹窗覆盖内容，悬浮导航盖住主体等。

    堆叠上下文的触发条件：

    1. 根元素（<html>）默认创建一个堆叠上下文
    2. position 为 absolute 或 relative，且 z-index 不为 auto。
    3. position 为 fixed 或 sticky。
    4. 设置 opacity 小于 1。
    5. 使用 transform、filter 等属性（非默认值）。
    6. display: flex 或 grid 的直接子元素，且 z-index 不为 auto。

    **z-index 作用**是控制定位元素的叠放顺序。需搭配 position: relative/absolute/fixed/sticky 使用，受堆叠上下文限制，值越大越靠前。

30. 如何实现一个三角形？

    在 CSS 中实现三角形通常有多种方法，主要利用 **边框（border）**、**剪切路径（clip-path）** 或 **SVG** 等技术。

    ```html
    // 1. 使用边框（Border）
    // 通过设置元素的宽高为 0，利用 border 的斜边特性形成三角形
    // 调整不同边框的颜色和宽度，保留需要的三角形部分。
    // 简单、兼容性好、只能创建直角三角形、调整大小需同步修改多个边框值
    <div class="triangle-up"></div>
    <style>
      .triangle-up {
        width: 0;
        height: 0;
        border-left: 50px solid transparent;
        border-right: 50px solid transparent;
        border-bottom: 50px solid red;
      }
    </style>
    
    // 2. 使用 clip-path
    // 通过 clip-path 属性剪裁元素，定义三角形的形状。
    // 支持任意多边形，灵活性高，支持动画，IE 不支持
    <div class="triangle-clip"></div>
    <style>
      .triangle-clip {
        width: 100px;
        height: 100px;
        background: green;
        clip-path: polygon(50% 0, 0 100%, 100% 100%);
      }
    </style>
    
    // 3. 使用 SVG，使用 <svg> 标签绘制矢量三角形，精确控制形状和样式。
    // 矢量图形，可缩放无失真 支持填充、描边、动画
    // 代码量稍多。不如 CSS 直观。
    <svg width="100" height="100">
      <polygon points="50,0 0,100 100,100" fill="orange" />
    </svg>
        
    // 4. 使用旋转（transform）
    // 创建一个矩形，通过 transform: rotate 旋转并通过容器裁剪成三角
    // 简单，易于调整角度 支持动画 需额外裁剪 不够精确
    <div class="triangle-rotate"></div>
    <style>
      .triangle-rotate {
        width: 50px;
        height: 50px;
        background: pink;
        transform: rotate(45deg);
        position: absolute;
        top: 25px;
        left: 25px;
      }
    </style>
    ```

    | **方法**  | **优点**       | **缺点**                 | **适用场景**         |
    | --------- | -------------- | ------------------------ | -------------------- |
    | border    | 简单，兼容性好 | 仅限直角三角，调整复杂   | 箭头、提示框         |
    | clip-path | 灵活，支持动画 | 浏览器支持有限，坐标复杂 | 动态效果、复杂形状   |
    | SVG       | 矢量，精确控制 | 代码较多，不够直观       | 图标、设计需求       |
    | transform | 简单，支持动画 | 需裁剪，不精确           | 装饰性三角、过渡效果 |

31. CSS 中的 overflow 属性有哪些值？

    | **值**      | **描述**                                     | **是否裁剪** | **滚动条**           | **溢出内容可访问** | **触发 BFC** | **适用场景**             | **浏览器支持**          |
    | ----------- | -------------------------------------------- | ------------ | -------------------- | ------------------ | ------------ | ------------------------ | ----------------------- |
    | **visible** | 溢出内容可见，超出容器边界显示               | 否           | 无                   | 是                 | 否           | 默认行为，装饰性溢出     | 所有浏览器              |
    | **hidden**  | 溢出内容被裁剪，不显示                       | 是           | 无                   | 否                 | 是           | 隐藏多余内容、清除浮动   | 所有浏览器              |
    | **scroll**  | 溢出内容裁剪，始终提供滚动条                 | 是           | 始终显示             | 是                 | 是           | 固定高度窗口、强制滚动   | 所有浏览器              |
    | **auto**    | 溢出时裁剪并提供滚动条，无溢出时无滚动条     | 是           | 按需显示             | 是                 | 是           | 智能滚动、动态内容       | 所有浏览器              |
    | **clip**    | 溢出内容裁剪，不提供滚动条，无法访问溢出部分 | 是           | 无                   | 否                 | 否           | 严格裁剪、遮罩效果       | 现代浏览器 (Chrome 90+) |
    | **overlay** | 类似 auto，滚动条覆盖内容而不占空间          | 是           | 按需显示（覆盖内容） | 是                 | 是           | 老式浮动滚动条（已废弃） | 部分老浏览器，已废弃    |

32. 什么是 CSS 动画？如何实现？

    CSS 动画是指通过 CSS 属性控制 HTML 元素的样式随时间变化的技术，用于创建动态效果（如移动、旋转、缩放、颜色渐变等）。相比传统的 JavaScript 动画，CSS 动画由浏览器原生支持，性能更高，代码更简洁。它主要通过 **@keyframes** 规则和 **animation** 属性实现。

    CSS 动画的实现主要分为两步，一是定义动画关键帧（@keyframes），指定动画的起始、结束及中间状态；二是应用动画（animation 属性），将动画绑定到元素并设置播放参数。

    ```css
    // 定义关键帧
    @keyframes 动画名称 {
      from { /* 起始状态 */ }
      to { /* 结束状态 */ }
    }
    // 使用百分比定义关键帧
    @keyframes 动画名称 {
      0% { /* 起始状态 */ }
      50% { /* 中间状态 */ }
      100% { /* 结束状态 */ }
    }
    
    // 应用动画
    animation: 动画名称 持续时间 [速度曲线] [延迟] [次数] [方向] [填充模式] [播放状态];
    .box {
      width: 100px;
      height: 100px;
      background: lightblue;
      animation: move 2s ease 1s infinite alternate forwards;
    }
    ```

    ######  **动画属性详解**

    | **属性**                  | **作用**             | **常见值**                 |
    | ------------------------- | -------------------- | -------------------------- |
    | animation-name            | 指定 @keyframes 名称 | move, fade 等              |
    | animation-duration        | 动画一次的持续时间   | 2s, 500ms                  |
    | animation-timing-function | 动画速度曲线         | ease, linear, ease-in-out  |
    | animation-delay           | 动画开始前的延迟     | 1s, 0s                     |
    | animation-iteration-count | 播放次数             | 1, infinite, 3             |
    | animation-direction       | 播放方向             | normal, reverse, alternate |
    | animation-fill-mode       | 动画结束后的状态     | none, forwards, backwards  |
    | animation-play-state      | 控制播放状态         | running, paused            |

    ###### **与 transition 的对比**

    | **特性**     | **animation**              | **transition**          |
    | ------------ | -------------------------- | ----------------------- |
    | **控制方式** | 通过 @keyframes 定义多状态 | 仅过渡起始和结束状态    |
    | **触发条件** | 自动播放或动态控制         | 需状态变化（如 :hover） |
    | **复杂性**   | 支持复杂动画               | 简单平滑过渡            |
    | **示例**     | 无限循环移动               | 鼠标悬停放大            |

    CSS 动画由浏览器渲染引擎处理，性能优于 JS。使用 transform 和 opacity，避免触发重排（如 width）；避免过多动画影响页面流畅度。

33. CSS 中的 transition 属性有什么作用？

    transition 是 CSS 中用于创建**平滑过渡效果**的属性，它可以在元素的可变样式（如宽度、颜色、位置等）从一个状态切换到另一个状态时添加动画效果。相比 @keyframes 和 animation，transition 更适合简单、基于状态变化的动画，例如鼠标悬停、点击触发的样式变化。

    ```css
    transition: 属性名 持续时间 [速度曲线] [延迟];
    ```

    transition 是一个简写属性，包含以下子属性：

    | **子属性**                     | **作用**                | **常见值**                |
    | ------------------------------ | ----------------------- | ------------------------- |
    | **transition-property**        | 指定需要过渡的 CSS 属性 | width, color, all         |
    | **transition-duration**        | 设置过渡持续时间        | 1s, 500ms                 |
    | **transition-timing-function** | 定义过渡速度曲线        | ease, linear, ease-in-out |
    | **transition-delay**           | 设置过渡开始前的延迟    | 0s, 1s                    |

    ###### **速度曲线（transition-timing-function）**

    - **linear**：匀速。
    - **ease**：慢-快-慢（默认）。
    - **ease-in**：慢速开始。
    - **ease-out**：慢速结束。
    - **ease-in-out**：慢速开始和结束。
    - **cubic-bezier(x1, y1, x2, y2)**：自定义曲线。
      - 示例：transition: width 1s cubic-bezier(0.68, -0.55, 0.27, 1.55);（弹簧效果）。

    注意事项：优先使用 transform 和 opacity，触发硬件加速，避免过渡 width、height 等重排属性；现代浏览器全支持；不能自动循环，需搭配 JS 或伪类触发。

34. Flex 布局的核心属性有哪些？

    Flex 布局（弹性盒布局，Flexible Box Layout）是 CSS 中一种强大的布局模型，旨在简化一维布局（如水平或垂直排列），通过弹性分配空间实现自适应效果。它由**容器属性**（作用于父元素）和**项目属性**（作用于子元素）两部分组成。

    ###### **Flex 容器属性（作用于父元素）**

    容器属性定义在设置了 display: flex 或 display: inline-flex 的容器上，控制整体布局行为。

    | **属性**            | **作用**           | **常见值**                                                   | **说明**                                    |
    | ------------------- | ------------------ | ------------------------------------------------------------ | ------------------------------------------- |
    | **display**         | 启用 Flex 布局     | flex, inline-flex                                            | flex 创建块级容器，inline-flex 创建行内容器 |
    | **flex-direction**  | 定义主轴方向       | row, column, row-reverse, column-reverse                     | 决定子元素排列方向（水平或垂直）            |
    | **flex-wrap**       | 控制是否换行       | nowrap, wrap, wrap-reverse                                   | 处理子元素超出容器时的行为                  |
    | **justify-content** | 主轴上的对齐方式   | flex-start, center, space-between, space-around, space-evenly | 分配主轴剩余空间，调整子元素位置            |
    | **align-items**     | 交叉轴上的对齐方式 | stretch, flex-start, center, flex-end, baseline              | 控制子元素在交叉轴的排列                    |
    | **align-content**   | 多行时的交叉轴对齐 | flex-start, center, space-between, space-around, space-evenly | 仅在 flex-wrap 为 wrap 时生效               |
    | **gap**             | 设置子元素间距     | 10px, 20px 10px                                              | 替代 margin，定义行间距和列间距             |

    ###### **Flex 项目属性（作用于子元素）**

    项目属性定义在 Flex 容器的直接子元素上，控制单个项目的弹性行为和位置。

    | **属性**        | **作用**                         | **常见值**                                  | **说明**                                |
    | --------------- | -------------------------------- | ------------------------------------------- | --------------------------------------- |
    | **flex**        | 简写属性，控制弹性比例和基础尺寸 | 1, 0 1 auto, 1 0 50px                       | 包含 flex-grow、flex-shrink、flex-basis |
    | **flex-grow**   | 分配剩余空间的增长比例           | 0, 1, 2                                     | 默认 0，决定是否扩展以填充剩余空间      |
    | **flex-shrink** | 压缩比例（空间不足时）           | 1, 0, 2                                     | 默认 1，决定是否收缩以适应容器          |
    | **flex-basis**  | 设置项目的初始主轴尺寸           | auto, 50px, 20%                             | 默认 auto，优先级高于 width/height      |
    | **order**       | 调整排列顺序                     | 0, 1, -1                                    | 默认 0，值越小越靠前                    |
    | **align-self**  | 单独控制交叉轴对齐               | auto, flex-start, center, flex-end, stretch | 覆盖容器的 align-items                  |

35. Grid 布局与 Flex 的区别是什么？

    **Grid 布局（CSS Grid Layout）** 和 **Flex 布局（Flexible Box Layout）** 是 CSS 中两种现代布局模型，分别适用于不同场景。Flex 擅长一维布局（行或列），而 Grid 专注于二维布局（行列同时控制）。

    ###### **区别对比表格**

    | **特性**       | **Flex 布局**                                | **Grid 布局**                                            |
    | -------------- | -------------------------------------------- | -------------------------------------------------------- |
    | **布局维度**   | 一维（主轴方向，行或列）                     | 二维（行列同时控制）                                     |
    | **核心属性**   | flex-direction, justify-content, align-items | grid-template-columns, grid-template-rows, justify-items |
    | **内容驱动**   | 是（内容决定布局）                           | 否（网格定义布局）                                       |
    | **对齐方式**   | 主轴和交叉轴对齐                             | 网格单元格内的对齐                                       |
    | **项目顺序**   | 通过 order 调整                              | 通过 grid-column/grid-row 精确指定                       |
    | **间距控制**   | gap（CSS3 新增）                             | gap（行间距和列间距独立控制）                            |
    | **复杂布局**   | 需嵌套实现复杂结构                           | 直接支持复杂行列布局                                     |
    | **适用场景**   | 单行/单列、动态内容                          | 多行多列、固定网格                                       |
    | **浏览器支持** | 更早（2012+，IE10+ 前缀）                    | 较新（2017+，IE11 前缀）                                 |

36. CSS 中的 visibility 和 display: none 的区别？

    visibility、display: none 和 opacity: 0 都是 CSS 中用于控制元素可见性的属性，但它们的作用方式和影响范围不同。其中 visibility 和 display: none 用于影藏元素。

    | **属性**       | **display: none**         | **visibility: hidden**                          | **opacity: 0**                  |
    | -------------- | ------------------------- | ----------------------------------------------- | ------------------------------- |
    | **作用**       | 完全移除元素，不渲染      | 隐藏元素，但保留空间                            | 元素透明，但仍占空间            |
    | **占用空间**   | 否（从布局中移除）        | 是（占位但不可见）                              | 是（占位且可交互）              |
    | **渲染状态**   | 不渲染（不生成盒模型）    | 渲染但不可见                                    | 渲染且完全透明                  |
    | **子元素继承** | 子元素也移除              | 子元素默认隐藏，可通过 visibility: visible 显示 | 子元素透明，可通过 opacity 覆盖 |
    | **事件响应**   | 不可点击或交互            | 不可点击或交互                                  | 可点击或交互                    |
    | **过渡动画**   | 不支持（无法过渡到 none） | 支持（visible ↔ hidden）                        | 支持（0 ↔ 1 平滑过渡）          |
    | **性能影响**   | 最优（不渲染）            | 中等（仍需计算布局）                            | 较差（需渲染透明效果）          |
    | **常见用途**   | 条件隐藏、节省资源        | 临时隐藏但保留布局                              | 淡入淡出动画                    |

37. 如何实现一个圆形进度条？

    SVG（精确）、Border（传统）、Conic Gradient（现代）。SVG 适合动态交互，Conic Gradient 适合现代简洁设计。

    ```html
    // 1. 使用 SVG
    // 使用 SVG 的 circle 标签绘制圆环，通过 stroke-dasharray 和 stroke-dashoffset 控制进度
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .progress-ring {
          transform: rotate(-90deg); /* 从顶部开始 */
        }
        .progress-ring__circle {
          transition: stroke-dashoffset 0.5s ease;
        }
      </style>
    </head>
    <body>
      <svg class="progress-ring" width="120" height="120">
        <circle class="progress-ring__background" cx="60" cy="60" r="50" stroke="#e0e0e0" stroke-width="10" fill="none" />
        <circle class="progress-ring__circle" cx="60" cy="60" r="50" stroke="#4caf50" stroke-width="10" fill="none" stroke-dasharray="314" stroke-dashoffset="94.2" />
      </svg>
    
      <script>
        const circle = document.querySelector('.progress-ring__circle');
        const circumference = 2 * Math.PI * 50; // 周长 = 2πr
        circle.setAttribute('stroke-dasharray', circumference);
    
        function setProgress(percent) {
          const offset = circumference - (percent / 100) * circumference;
          circle.setAttribute('stroke-dashoffset', offset);
        }
    
        // 示例：设置 70% 进度
        setProgress(70);
      </script>
    </body>
    </html>
    
    // 2. 使用 css 的边框
    // 用两个半圆拼接成圆环，通过旋转控制进度
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .progress-circle {
          position: relative;
          width: 100px;
          height: 100px;
        }
        .circle {
          position: absolute;
          width: 100%;
          height: 100%;
          border: 10px solid;
          border-radius: 50%;
          box-sizing: border-box;
        }
        .background {
          border-color: #e0e0e0;
        }
        .left, .right {
          border-color: transparent #4caf50 #4caf50 transparent;
          clip-path: polygon(50% 0, 100% 0, 100% 100%, 50% 100%);
        }
        .right {
          transform: rotate(0deg); /* 初始 0% */
          transition: transform 0.5s ease;
        }
      </style>
    </head>
    <body>
      <div class="progress-circle">
        <div class="circle background"></div>
        <div class="circle left"></div>
        <div class="circle right" id="progress"></div>
      </div>
    
      <script>
        const progress = document.getElementById('progress');
        function setProgress(percent) {
          const angle = Math.min(percent * 3.6, 360); // 百分比转角度 (100% = 360°)
          progress.style.transform = `rotate(${angle}deg)`;
        }
        setProgress(75); // 设置 75%
      </script>
    </body>
    </html>
    
    // 3. 使用 CSS 圆锥渐变
    // 使用 conic-gradient 创建圆形渐变，通过角度控制进度
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .progress-conic {
          width: 100px;
          height: 100px;
          background: conic-gradient(#4caf50 0deg 270deg, #e0e0e0 270deg 360deg);
          border-radius: 50%;
          position: relative;
        }
        .inner {
          position: absolute;
          top: 10px;
          left: 10px;
          width: 80px;
          height: 80px;
          background: white;
          border-radius: 50%;
        }
      </style>
    </head>
    <body>
      <div class="progress-conic">
        <div class="inner"></div>
      </div>
        
      <script>
        const progress = document.querySelector('.progress-conic');
        function setProgress(percent) {
          const angle = percent * 3.6;
          progress.style.background = `conic-gradient(#4caf50 0deg ${angle}deg, #e0e0e0 ${angle}deg 360deg)`;
        }
        setProgress(75);
      </script>
    </body>
    </html>
    ```

38. CSS 中的 calc() 函数有什么用？

    calc() 是 CSS 中的一个计算函数，用于在样式中动态计算长度值。它允许开发者在 CSS 属性值中执行数学运算（如加、减、乘、除），并支持不同单位（如 px、%、em、vw）的混合计算。calc() 在运行时由浏览器解析，特别适合响应式布局和复杂尺寸计算。结合 CSS 变量增强可维护性。

    支持运算符、必须有空格（运算符两边需空格）、支持单位：px、em、rem、vh、vw、% 等

    ```css
    calc(表达式)
    // 
    width: calc(100% - 40px);
    ```

39. 如何使用 CSS 实现多列布局？

    文本分列用 columns，动态用 Flex，复杂用 Grid；推荐 Flex 和 Grid，Float 仅用于兼容；Grid 和 Flex 更高效，columns 适合内容驱动。

    ```html
    // 1. 使用 columns 属性
    // columns 是 CSS 多列布局模块（CSS Multi-column Layout）的核心属性，直接将内容分成多列，类似报纸排版。
    // columns：简写，包含 column-count（列数）和 column-width（列宽）
    // column-fill：填充方式（balance 或 auto）
    // 简单，适合纯文本分列、内容自动流动；控制有限，不适合复杂布局。子元素难以单独定位。
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .multi-column {
          columns: 3 200px; /* 3 列，每列最小宽度 200px */
          column-gap: 20px; /* 列间距 */
          column-rule: 1px solid #ccc; /* 分隔线 */
        }
        .multi-column p {
          margin: 0 0 10px;
        }
      </style>
    </head>
    <body>
      <div class="multi-column">
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
        <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
        <p>Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.</p>
      </div>
    </body>
    </html>
    
    // 2. 使用 Flexbox
    // Flexbox 是一维弹性布局，通过 flex 属性分配空间，适合水平或垂直多列
    // 弹性分配空间，响应式强、支持对齐和顺序调整；一维布局，多行需嵌套。
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .flex-container {
          display: flex;
          gap: 20px;
        }
        .flex-column {
          flex: 1; /* 均分空间 */
          background: lightblue;
          padding: 10px;
        }
      </style>
    </head>
    <body>
      <div class="flex-container">
        <div class="flex-column">列 1: Lorem ipsum dolor sit amet.</div>
        <div class="flex-column">列 2: Consectetur adipiscing elit.</div>
        <div class="flex-column">列 3: Sed do eiusmod tempor.</div>
      </div>
    </body>
    </html>
    
    // 3. 使用 Grid
    // Grid 是二维布局，通过定义行列网格实现多列，适合复杂结构
    // 二维控制，适合复杂布局、精确指定列宽和位置
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .grid-container {
          display: grid; // 启用 Grid 布局
          grid-template-columns: repeat(3, 1fr); /* 3 等宽列 */
          gap: 20px;
        }
        .grid-column {
          background: lightgreen;
          padding: 10px;
        }
      </style>
    </head>
    <body>
      <div class="grid-container">
        <div class="grid-column">列 1: Lorem ipsum dolor sit amet.</div>
        <div class="grid-column">列 2: Consectetur adipiscing elit.</div>
        <div class="grid-column">列 3: Sed do eiusmod tempor.</div>
      </div>
    </body>
    </html>
    
    // 4. 使用 Float
    // 使用 float 将元素浮动排列，需清除浮动以维持布局
    // 需处理浮动副作用 不够灵活
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .float-container {
          overflow: hidden; /* 触发 BFC 清除浮动 */
        }
        .float-column {
          float: left;
          width: 33.33%;
          padding: 10px;
          box-sizing: border-box;
          background: lightcoral;
        }
      </style>
    </head>
    <body>
      <div class="float-container">
        <div class="float-column">列 1: Lorem ipsum.</div>
        <div class="float-column">列 2: Consectetur.</div>
        <div class="float-column">列 3: Sed do.</div>
      </div>
    </body>
    </html>
    ```

40. 什么是 CSS 的伪元素（pseudo-element）？

    CSS 中的**伪元素（Pseudo-element）** 是一种特殊的 CSS 选择器，用于在不修改 HTML 结构的情况下，向元素添加虚拟的“子元素”或修饰特定部分。伪元素通过 CSS 创建，模拟 DOM 树中的额外内容，主要用于样式化元素的特定区域（如首字母、首行）或添加装饰性内容（如前后标记）。它不存在于实际 DOM 中，仅在渲染层生效；以双冒号 :: 开头（如 ::before），部分旧伪元素也支持单冒号 :（如 :before）。

    | **伪元素**         | **作用**                           | **常见用法**           |
    | ------------------ | ---------------------------------- | ---------------------- |
    | **::before**       | 在元素内容前插入虚拟内容           | 添加前置图标、装饰     |
    | **::after**        | 在元素内容后插入虚拟内容           | 添加后置标记、清除浮动 |
    | **::first-line**   | 样式化元素的首行文本               | 首行加粗、变色         |
    | **::first-letter** | 样式化元素的首字母                 | 首字母放大、下沉       |
    | **::selection**    | 样式化用户选中的文本               | 自定义高亮颜色         |
    | **::marker**       | 样式化列表项的标记（如圆点、数字） | 自定义列表符号         |

    ::before 和 ::after 需配合 content 属性使用；::first-line 和 ::first-letter 仅适用于块级元素。

    **与伪类（Pseudo-class）的区别**

    | **特性**     | **伪元素（Pseudo-element）** | **伪类（Pseudo-class）** |
    | ------------ | ---------------------------- | ------------------------ |
    | **语法**     | 双冒号 ::                    | 单冒号 :                 |
    | **作用对象** | 虚拟元素或部分               | 元素状态                 |
    | **示例**     | ::before, ::first-line       | :hover, :focus           |
    | **功能**     | 添加内容或样式化部分         | 根据状态调整样式         |

41. CSS 中的 opacity 和 rgba 的区别？

    opacity 和 rgba 都是 CSS 中用于控制元素透明度的属性，但它们的作用方式、应用范围和效果有所不同。

    | **特性**     | **opacity**                     | **rgba**                          |
    | ------------ | ------------------------------- | --------------------------------- |
    | **定义**     | 属性，控制整个元素的透明度      | 颜色函数，定义带透明度的颜色值    |
    | **取值范围** | 0（完全透明）到 1（完全不透明） | rgba(r, g, b, a)，a 为 0-1        |
    | **作用范围** | 整个元素（包括子元素）          | 仅应用到指定的颜色属性（如背景）  |
    | **继承性**   | 子元素继承透明效果，无法覆盖    | 子元素不继承透明度，可独立设置    |
    | **性能影响** | 创建新堆叠上下文，影响渲染      | 仅影响颜色计算，性能较轻量        |
    | **适用属性** | 独立属性，作用于元素整体        | 用于 color、background 等颜色属性 |
    | **动画支持** | 支持（如淡入淡出）              | 支持（透明度渐变）                |
    | **常见用途** | 整体隐藏或淡化效果              | 背景或文字的透明效果              |

    ```
    // 语法
    rgba(red, green, blue, alpha);
    opacity: 值;
    ```

42. 如何实现一个自适应正方形？

    自适应正方形是指一个元素的宽度和高度始终保持相等，并且能够根据容器大小或视口变化动态调整。

    ```html
    // 1. 使用 padding-top 或 padding-bottom
    // 在 CSS 中，padding 的百分比值是基于父元素宽度计算的。通过设置 padding-top 或 padding-bottom 为 100%，可以让高度等于宽度。
    // 一般用于传统布局
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .square-container {
          width: 50%; /* 自适应容器宽度 */
          position: relative;
        }
        .square {
          padding-top: 100%; /* 高度 = 宽度 */
          background: lightblue;
        }
        .content {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          display: flex;
          align-items: center;
          justify-content: center;
        }
      </style>
    </head>
    <body>
      <div class="square-container">
        <div class="square">
          <div class="content">正方形</div>
        </div>
      </div>
    </body>
    </html>
    
    // 2. 使用 vw 或 vh 单位
    // 使用视口单位（如 vw 或 vh）设置宽度和高度，确保两者相等并随视口缩放
    // 适用于全屏设计、固定比例元素
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .square {
          width: 20vw; /* 视口宽度的 20% */
          height: 20vw; /* 保持相等 */
          background: lightgreen;
          display: flex;
          align-items: center;
          justify-content: center;
        }
      </style>
    </head>
    <body>
      <div class="square">正方形</div>
    </body>
    </html>
    
    // 3. 使用 aspect-ratio 属性
    // aspect-ratio 是 CSS 的新属性（CSS Box Sizing Module Level 4），用于设置元素的宽高比。设置为 1 / 1 可实现正方形。
    // 适用于现代项目、响应式布局
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .square {
          width: 50%; /* 自适应父容器宽度 */
          aspect-ratio: 1 / 1; /* 宽高比 1:1 */
          background: lightcoral;
          display: flex;
          align-items: center;
          justify-content: center;
        }
      </style>
    </head>
    <body>
      <div class="square">正方形</div>
    </body>
    </html>
    
    // 4. 使用 Grid 布局
    // Grid 可以通过设置 grid-template-columns 和 grid-template-rows 为相同值实现正方形
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .square {
          display: grid;
          grid-template-columns: 1fr;
          grid-template-rows: 1fr;
          width: 50%; /* 自适应父容器 */
          aspect-ratio: 1 / 1; /* 或依赖内容 */
          background: lightyellow;
          place-items: center;
        }
      </style>
    </head>
    <body>
      <div class="square">正方形</div>
    </body>
    </html>
    
    // 总结
    // 推荐使用 aspect-ratio + 回退方案，兼顾现代性和兼容性
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        .square {
          width: 50%;
          background: lightpink;
          position: relative;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .square::before {
          content: "";
          padding-top: 100%; /* 回退方案 */
        }
        @supports (aspect-ratio: 1 / 1) {
          .square {
            aspect-ratio: 1 / 1; /* 现代方案 */
          }
          .square::before {
            padding-top: 0; /* 支持 aspect-ratio 时禁用回退 */
          }
        }
      </style>
    </head>
    <body>
      <div class="square">自适应正方形</div>
    </body>
    </html>
    ```

43. CSS 中的 clip-path 有什么作用？

    clip-path 是 CSS 中的一个属性，用于**裁剪元素的可视区域**，定义一个裁剪路径，只有路径内的内容可见，超出部分被隐藏。它可以创建各种形状（如圆形、多边形、椭圆），常用于设计创意布局或动画效果。

    ```css
    clip-path: <clip-source> | <basic-shape> | none;
    // 取值
    <clip-source>：如 url(#clip-id)（引用 SVG 剪裁路径）。
    <basic-shape>：基本形状函数：
    circle()：圆形 circle(半径 at 中心x 中心y)，50% 表示半径为宽度的一半
    ellipse()：椭圆。ellipse(50% 25% at 50% 50%)
    polygon()：多边形。polygon(x1 y1, x2 y2, x3 y3)，定义三个顶点坐标
    inset()：矩形内缩。inset(20px 40px 20px 40px) 上下内缩 20px，左右内缩 40px
    none：无裁剪（默认）。
    
    // 动画效果
    <div class="animate"></div>
    <style>
      .animate {
        width: 100px;
        height: 100px;
        background: lightpink;
        clip-path: circle(0% at 50% 50%);
        transition: clip-path 1s ease;
      }
      .animate:hover {
        clip-path: circle(50% at 50% 50%);
      }
    </style>
    ```

44. 如何清除浮动？

    在 CSS 中，浮动（float）会导致元素脱离正常文档流，可能引发父元素高度塌陷等问题。清除浮动是指通过特定方法恢复父元素的正常高度或确保后续元素不受浮动影响。

    ```html
    // 1. 使用 clear 属性
    // 原理: 在浮动元素后添加一个元素，设置 clear 属性，强制其显示在浮动元素下方
    <div class="container">
      <div class="float">浮动</div>
      <div class="clear"></div>
    </div>
    <style>
      .float {
        float: left;
        width: 100px;
        height: 100px;
        background: lightblue;
      }
      .clear {
        clear: both; /* 清除左右浮动 */
      }
      .container {
        background: #f0f0f0;
      }
    </style>
    
    // 2. 使用伪元素 ::after（推荐）
    // 原理: 通过 ::after 伪元素在浮动元素的父容器末尾添加一个不可见的块元素，并设置 clear: both。
    <div class="container">
      <div class="float">浮动</div>
    </div>
    <style>
      .container::after {
        content: "";
        display: block;
        clear: both;
      }
      .float {
        float: left;
        width: 100px;
        height: 100px;
        background: lightgreen;
      }
      .container {
        background: #f0f0f0;
      }
    </style>
    
    // 3. 触发 BFC（Block Formatting Context）
    // 原理: 通过设置父容器的特定 CSS 属性（如 overflow: hidden），触发块级格式化上下文，使其包含浮动子元素。
    // overflow: hidden | auto | scroll。
    // display: flow-root（现代方法）。
    // float: left | right。
    // position: absolute | fixed。
    <div class="container">
      <div class="float">浮动</div>
    </div>
    <style>
      .container {
        overflow: hidden; /* 触发 BFC */
        background: #f0f0f0;
      }
      .float {
        float: left;
        width: 100px;
        height: 100px;
        background: lightcoral;
      }
    </style>
    
    // 推荐 ::after 或 display: flow-root
    ```

45. CSS 中的 will-change 属性有什么用？

    will-change 是 CSS 中的一个优化属性，用于**提前告知浏览器某个元素即将发生的变化**（如动画、变换或定位），以便浏览器预先为其分配资源（如独立的图层），从而提升性能和减少重绘或回流的开销。

46. 如何实现文字溢出省略号？

47. CSS 中的 box-shadow 如何使用？

48. 什么是 CSS 的 currentColor？

49. 如何实现一个响应式导航栏？

50. CSS 中的 media 查询如何使用？
