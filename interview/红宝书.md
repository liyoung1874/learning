以下是《JavaScript高级程序设计》第1章的详细笔记和面试题，格式化为 Markdown，方便复制和使用：

---

# 第1章：JavaScript简介

## 1.1 JavaScript的起源与发展

- **诞生背景**：
  - 1995年，由 Brendan Eich 在 10 天内开发完成，最初命名为“Mocha”。
  - 后更名为“LiveScript”，最终与 Java 合作营销，改名为“JavaScript”。
  - 目标：为网页提供动态交互功能。

- **标准化**：
  - 1997年，ECMAScript（ECMA-262）成为 JavaScript 的标准。
  - ECMAScript 是语言的核心规范，JavaScript 是其实现之一。

- **主要版本**：
  - **ES3 (1999)**：广泛支持，奠定基础。
  - **ES5 (2009)**：引入严格模式、JSON 支持、数组方法扩展等。
  - **ES6/ES2015 (2015)**：重大更新，包括类、模块、箭头函数、Promise 等。
  - **ES2016+**：每年发布小幅更新（如 Async/Await、Rest/Spread 等）。

---

## 1.2 JavaScript的组成

JavaScript由以下三部分组成：

1. **ECMAScript**：
   - 定义了语言的核心语法和功能。
   - 包括：变量、数据类型、操作符、控制语句、函数、对象等。

2. **DOM (文档对象模型)**：
   - 提供操作 HTML 和 XML 文档的 API。
   - 允许开发者动态操作网页内容和结构。

3. **BOM (浏览器对象模型)**：
   - 提供与浏览器交互的 API。
   - 包括：控制窗口、导航历史、屏幕信息、Cookie 等。

---

## 1.3 ECMAScript与JavaScript的关系

- **ECMAScript**是 JavaScript 的语言标准，由 ECMA-262 规范定义。
- **JavaScript**是 ECMAScript 的实现之一，扩展了 DOM 和 BOM 功能，用于浏览器环境。

---

## 1.4 JavaScript的特点

1. **解释型语言**：无需编译，直接由浏览器解释执行。
2. **动态类型**：变量类型在运行时确定，支持隐式类型转换。
3. **基于原型的面向对象**：通过原型链实现继承，而非传统的类继承。
4. **单线程**：JavaScript 在浏览器中是单线程运行，通过事件循环处理异步任务。
5. **弱类型**：变量可以随时改变类型，可能导致隐式类型转换问题。
6. **跨平台**：只要有 JavaScript 引擎，就可以运行（如浏览器、Node.js）。

---

## 1.5 JavaScript的用途

1. **前端开发**：
   - 操作 DOM，动态更新网页内容。
   - 实现用户交互（如表单验证、动画效果）。
   - 构建单页应用（SPA）和复杂的前端框架（如 React、Vue、Angular）。

2. **后端开发**：
   - 使用 Node.js 构建服务器端应用。
   - 实现实时通信（如 WebSocket）。

3. **全栈开发**：
   - 前后端统一使用 JavaScript，提升开发效率。

4. **其他场景**：
   - 移动应用开发（如 React Native）。
   - 桌面应用开发（如 Electron）。
   - 嵌入式开发和物联网（IoT）。

---

## 1.6 浏览器中的JavaScript引擎

- **JavaScript引擎**：
  - 负责解析和执行 JavaScript 代码。
  - 现代引擎会将 JavaScript 代码编译为高效的机器码。

- **主流引擎**：
  - V8：Chrome 和 Node.js 使用。
  - SpiderMonkey：Firefox 使用。
  - JavaScriptCore (Nitro)：Safari 使用。
  - Chakra：旧版 Edge 使用（新版 Edge 使用 V8）。

---

## 1.7 JavaScript的局限性

1. **单线程模型**：
   - 无法同时处理多个任务，但可以通过异步机制（如 Promise、async/await）解决。

2. **浏览器依赖**：
   - 早期 JavaScript 依赖浏览器环境，现代通过 Node.js 扩展到服务器端。

3. **安全性**：
   - 代码在客户端运行，容易被篡改或恶意利用。

4. **弱类型问题**：
   - 隐式类型转换可能导致意外错误。

---

# 第一章：经典面试题及解析

## 1. 什么是JavaScript？它由哪几部分组成？

### 答案：
JavaScript是一种**基于原型的、动态类型的、解释型的脚本语言**，主要用于网页开发，也可以用于服务器端开发（如 Node.js）。

JavaScript由以下三部分组成：
1. **ECMAScript**：定义了语言的核心语法和功能（如变量、数据类型、操作符、控制语句、函数等）。
2. **DOM (文档对象模型)**：提供操作 HTML 和 XML 文档的 API，用于动态操作网页内容。
3. **BOM (浏览器对象模型)**：提供与浏览器交互的 API（如控制窗口、导航历史、屏幕信息、Cookie 等）。

---

## 2. ECMAScript和JavaScript有什么区别？

### 答案：
- **ECMAScript**是 JavaScript 的语言标准，由 ECMA-262 规范定义。
- **JavaScript**是 ECMAScript 的实现之一，扩展了 DOM 和 BOM 功能，用于浏览器环境。

---

## 3. JavaScript有哪些主要特点？

### 答案：
1. **解释型语言**：无需编译，直接由浏览器解释执行。
2. **动态类型**：变量类型在运行时确定，支持隐式类型转换。
3. **基于原型的面向对象**：通过原型链实现继承，而非传统的类继承。
4. **单线程**：JavaScript 在浏览器中是单线程运行，通过事件循环处理异步任务。
5. **弱类型**：变量可以随时改变类型，可能导致隐式类型转换问题。
6. **跨平台**：只要有 JavaScript 引擎，就可以运行（如浏览器、Node.js）。

---

## 4. 什么是事件循环？它如何处理异步任务？

### 答案：
事件循环是 JavaScript 的执行机制，用于处理异步任务。JavaScript 是单线程的，事件循环允许它在等待异步操作（如定时器、网络请求）完成时继续执行其他任务。

### 工作原理：
1. 主线程执行同步代码。
2. 异步任务（如 `setTimeout`）被放入任务队列。
3. 主线程空闲时，从任务队列中取出任务执行。

---

## 5. 面试实战题：解释以下代码的输出

```javascript
console.log(a); // ?
var a = 10;
console.log(a); // ?
```

### 答案：
1. 第一个 `console.log(a)` 输出 `undefined`。
   - 因为 `var` 声明的变量会被提升（hoisting），但值未赋予之前为 `undefined`。
2. 第二个 `console.log(a)` 输出 `10`。
   - 因为变量 `a` 已经被赋值为 `10`。

---

## 6. 面试实战题：解释以下代码的输出

```javascript
console.log(b); // ?
let b = 20;
console.log(b); // ?
```

### 答案：
1. 第一个 `console.log(b)` 会抛出 `ReferenceError`。
   - 因为 `let` 声明的变量存在**暂时性死区**（TDZ），在声明之前无法访问。
2. 第二个 `console.log(b)` 输出 `20`。
   - 因为变量 `b` 已经被赋值为 `20`。

---

以上是《JavaScript高级程序设计》第1章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第2章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第2章：HTML中的JavaScript

## 2.1 `<script>`标签

- **基本用法**：
  - 使用 `<script>` 标签将 JavaScript 嵌入 HTML 页面中。
  - 可以直接在 HTML 中编写脚本，也可以通过 `src` 属性引入外部脚本文件。

### 示例：
```html
<!-- 内联脚本 -->
<script>
  console.log("Hello, JavaScript!");
</script>

<!-- 外部脚本 -->
<script src="script.js"></script>
```

- **注意**：
  - `<script>` 标签可以放在 `<head>` 或 `<body>` 中。
  - 通常建议将 `<script>` 放在页面底部，避免阻塞页面渲染。

---

## 2.2 `<script>`标签的属性

1. **`src`**：
   - 指定外部 JavaScript 文件的路径。
   - 示例：
     ```html
     <script src="script.js"></script>
     ```

2. **`type`**：
   - 指定脚本的 MIME 类型。
   - 默认值为 `text/javascript`，现代浏览器可以省略。
   - 示例：
     ```html
     <script type="text/javascript">
       console.log("Type attribute example");
     </script>
     ```

3. **`defer`**：
   - 延迟脚本执行，直到 HTML 文档完全解析完毕。
   - 适用于外部脚本。
   - 示例：
     ```html
     <script src="script.js" defer></script>
     ```

4. **`async`**：
   - 异步加载脚本，脚本加载完成后立即执行，不保证执行顺序。
   - 适用于外部脚本。
   - 示例：
     ```html
     <script src="script.js" async></script>
     ```

---

## 2.3 脚本的加载与执行顺序

1. **默认行为**：
   - 浏览器会按顺序加载并执行 `<script>` 标签中的脚本。
   - 如果脚本在 `<head>` 中，可能会阻塞页面渲染。

2. **`defer` 和 `async` 的区别**：
   - `defer`：脚本按顺序执行，且在 HTML 文档解析完成后执行。
   - `async`：脚本加载完成后立即执行，可能打乱执行顺序。

### 示例：
```html
<!-- 默认加载顺序 -->
<script src="script1.js"></script>
<script src="script2.js"></script>

<!-- 使用 defer -->
<script src="script1.js" defer></script>
<script src="script2.js" defer></script>

<!-- 使用 async -->
<script src="script1.js" async></script>
<script src="script2.js" async></script>
```

---

## 2.4 动态脚本加载

- 可以通过 JavaScript 动态创建 `<script>` 标签，加载外部脚本。

### 示例：
```javascript
const script = document.createElement("script");
script.src = "script.js";
document.body.appendChild(script);
```

- **优点**：
  - 动态加载脚本可以实现按需加载，提升性能。
  - 常用于模块化开发或延迟加载。

---

## 2.5 `noscript`标签

- **定义**：
  - 当浏览器禁用 JavaScript 时，`<noscript>` 标签中的内容会显示。

### 示例：
```html
<noscript>
  <p>您的浏览器禁用了 JavaScript，请启用后继续访问。</p>
</noscript>
```

- **注意**：
  - 现代浏览器很少禁用 JavaScript，但仍需考虑兼容性。

---

## 2.6 文档模式

- **定义**：
  - 浏览器根据 HTML 文档的声明选择不同的渲染模式。

- **模式类型**：
  1. **标准模式 (Standards Mode)**：
     - 浏览器严格按照 W3C 标准解析和渲染页面。
  2. **怪异模式 (Quirks Mode)**：
     - 模拟旧版浏览器的行为，通常用于兼容老旧页面。
  3. **准标准模式 (Almost Standards Mode)**：
     - 类似标准模式，但对某些旧特性提供支持。

- **如何触发模式**：
  - 使用 `<!DOCTYPE>` 声明触发标准模式。
  - 示例：
    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <title>标准模式示例</title>
      </head>
      <body>
        <p>Hello, World!</p>
      </body>
    </html>
    ```

---

# 第二章：经典面试题及解析

## 1. `<script>`标签的 `defer` 和 `async` 有什么区别？

### 答案：
1. **`defer`**：
   - 脚本加载完成后，等待 HTML 文档解析完毕再按顺序执行。
   - 适合需要依赖 DOM 的脚本。

2. **`async`**：
   - 脚本加载完成后立即执行，不保证执行顺序。
   - 适合独立的脚本（如统计代码）。

### 示例：
```html
<script src="script1.js" defer></script>
<script src="script2.js" async></script>
```

---

## 2. 为什么建议将 `<script>` 标签放在页面底部？

### 答案：
- 如果 `<script>` 标签放在 `<head>` 中，浏览器会在加载和执行脚本时阻塞页面渲染，导致页面加载变慢。
- 将 `<script>` 放在页面底部，可以让浏览器优先加载和渲染 HTML 内容，提升用户体验。

---

## 3. 如何动态加载 JavaScript 脚本？

### 答案：
可以通过 JavaScript 动态创建 `<script>` 标签加载外部脚本。

### 示例：
```javascript
const script = document.createElement("script");
script.src = "script.js";
document.body.appendChild(script);
```

---

## 4. 面试实战题：以下代码的输出是什么？

```html
<!DOCTYPE html>
<html>
  <head>
    <script>
      console.log("Script in head");
    </script>
  </head>
  <body>
    <script>
      console.log("Script in body");
    </script>
  </body>
</html>
```

### 答案：
输出顺序为：
```
Script in head
Script in body
```

### 解析：
- 浏览器会按顺序加载和执行 `<script>` 标签中的代码。
- 第一个脚本在 `<head>` 中，页面解析到 `<head>` 时立即执行。
- 第二个脚本在 `<body>` 中，页面解析到 `<body>` 时执行。

---

## 5. 面试实战题：以下代码的输出是什么？

```html
<!DOCTYPE html>
<html>
  <head>
    <script src="script1.js" defer></script>
    <script src="script2.js" defer></script>
  </head>
  <body>
    <p>Hello, World!</p>
  </body>
</html>
```

### 答案：
- `script1.js` 和 `script2.js` 会按顺序执行。
- 它们会在 HTML 文档解析完成后执行。

### 解析：
- `defer` 属性保证脚本按顺序执行，并且在 HTML 文档解析完成后执行。

---

## 6. 面试实战题：以下代码的输出是什么？

```html
<!DOCTYPE html>
<html>
  <head>
    <script src="script1.js" async></script>
    <script src="script2.js" async></script>
  </head>
  <body>
    <p>Hello, World!</p>
  </body>
</html>
```

### 答案：
- `script1.js` 和 `script2.js` 的执行顺序不确定。
- 它们会在加载完成后立即执行。

### 解析：
- `async` 属性不保证脚本的执行顺序，脚本加载完成后立即执行。

---

以上是《JavaScript高级程序设计》第2章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。



以下是《JavaScript高级程序设计》第3章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第3章：语言基础

## 3.1 语法

1. **区分大小写**：
   - JavaScript 是区分大小写的语言。
   - 变量 `myVariable` 和 `myvariable` 是不同的。

2. **标识符**：
   - 必须以字母、下划线 `_` 或美元符号 `$` 开头。
   - 后续字符可以是字母、数字、下划线或美元符号。
   - 不能使用保留字（如 `if`、`for`、`class` 等）。

3. **注释**：
   - 单行注释：
   - 多行注释：`/* */`

4. **严格模式**：
   - 使用 `"use strict";` 启用严格模式。
   - 严格模式下会对某些错误进行限制（如禁止使用未声明的变量）。

---

## 3.2 变量

1. **声明变量**：
   - `var`：函数作用域，存在变量提升。
   - `let`：块级作用域，无变量提升。
   - `const`：块级作用域，声明后不可重新赋值。

2. **变量提升**：
   - `var` 声明的变量会被提升到作用域顶部，但值为 `undefined`。
   - 示例：
     ```javascript
     console.log(a); // undefined
     var a = 10;
     ```

3. **块级作用域**：
   - `let` 和 `const` 声明的变量只在块级作用域内有效。
   - 示例：
     ```javascript
     {
       let x = 10;
       console.log(x); // 10
     }
     console.log(x); // ReferenceError
     ```

---

## 3.3 数据类型

1. **原始类型**：
   - `Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`（ES6）、`BigInt`（ES10）。

2. **引用类型**：
   - `Object` 及其派生类型（如 `Array`、`Function`、`Date` 等）。

3. **类型检测**：
   - `typeof`：用于检测原始类型。
     ```javascript
     console.log(typeof 10); // "number"
     console.log(typeof "hello"); // "string"
     console.log(typeof undefined); // "undefined"
     console.log(typeof null); // "object" (历史遗留问题)
     ```
   - `instanceof`：用于检测引用类型。
     ```javascript
     console.log([] instanceof Array); // true
     console.log({} instanceof Object); // true
     ```

4. **类型转换**：
   - 显式转换：
     ```javascript
     let num = Number("123"); // 转为数字
     let str = String(123); // 转为字符串
     let bool = Boolean(1); // 转为布尔值
     ```
   - 隐式转换：
     ```javascript
     console.log(1 + "2"); // "12" (数字转为字符串)
     console.log("5" - 2); // 3 (字符串转为数字)
     ```

---

## 3.4 操作符

1. **算术操作符**：
   - `+`、`-`、`*`、`/`、`%`、`**`（幂运算符，ES6）。

2. **比较操作符**：
   - `==`：相等（会进行类型转换）。
   - `===`：全等（不进行类型转换）。
   - 示例：
     ```javascript
     console.log(5 == "5"); // true
     console.log(5 === "5"); // false
     ```

3. **逻辑操作符**：
   - `&&`（与）、`||`（或）、`!`（非）。

4. **赋值操作符**：
   - `=`、`+=`、`-=`、`*=`、`/=` 等。

5. **三元操作符**：
   - 语法：`condition ? expr1 : expr2`
   - 示例：
     ```javascript
     let result = 5 > 3 ? "yes" : "no";
     console.log(result); // "yes"
     ```

---

## 3.5 流程控制

1. **条件语句**：
   - `if-else`：
     ```javascript
     if (condition) {
       // code
     } else {
       // code
     }
     ```
   - `switch`：
     ```javascript
     switch (value) {
       case 1:
         // code
         break;
       case 2:
         // code
         break;
       default:
         // code
     }
     ```

2. **循环语句**：
   - `for`：
     ```javascript
     for (let i = 0; i < 5; i++) {
       console.log(i);
     }
     ```
   - `while`：
     ```javascript
     let i = 0;
     while (i < 5) {
       console.log(i);
       i++;
     }
     ```
   - `do-while`：
     ```javascript
     let i = 0;
     do {
       console.log(i);
       i++;
     } while (i < 5);
     ```

3. **跳转语句**：
   - `break`：跳出循环。
   - `continue`：跳过当前循环，进入下一次循环。

---

## 3.6 函数

1. **函数声明**：
   ```javascript
   function add(a, b) {
     return a + b;
   }
   ```

2. **函数表达式**：
   ```javascript
   const add = function (a, b) {
     return a + b;
   };
   ```

3. **箭头函数**（ES6）：
   ```javascript
   const add = (a, b) => a + b;
   ```

4. **默认参数**（ES6）：
   ```javascript
   function greet(name = "Guest") {
     console.log(`Hello, ${name}`);
   }
   greet(); // "Hello, Guest"
   ```

5. **Rest 参数**（ES6）：
   ```javascript
   function sum(...numbers) {
     return numbers.reduce((total, num) => total + num, 0);
   }
   console.log(sum(1, 2, 3)); // 6
   ```

---

# 第三章：经典面试题及解析

## 1. `var`、`let` 和 `const` 的区别是什么？

### 答案：
1. **`var`**：
   - 函数作用域。
   - 存在变量提升。
   - 可以重复声明。

2. **`let`**：
   - 块级作用域。
   - 不存在变量提升。
   - 不允许重复声明。

3. **`const`**：
   - 块级作用域。
   - 不存在变量提升。
   - 声明后必须赋值，且不可重新赋值。

---

## 2. 以下代码的输出是什么？

```javascript
console.log(a); // ?
var a = 10;
console.log(a); // ?
```

### 答案：
1. 第一个 `console.log(a)` 输出 `undefined`。
   - 因为 `var` 声明的变量会被提升，但值未赋予之前为 `undefined`。
2. 第二个 `console.log(a)` 输出 `10`。

---

## 3. 以下代码的输出是什么？

```javascript
console.log(b); // ?
let b = 20;
console.log(b); // ?
```

### 答案：
1. 第一个 `console.log(b)` 抛出 `ReferenceError`。
   - 因为 `let` 声明的变量存在**暂时性死区**（TDZ），在声明之前无法访问。
2. 第二个 `console.log(b)` 输出 `20`。

---

## 4. 如何检测一个变量的类型？

### 答案：
1. 使用 `typeof` 检测原始类型：
   ```javascript
   console.log(typeof 123); // "number"
   console.log(typeof "hello"); // "string"
   ```

2. 使用 `instanceof` 检测引用类型：
   ```javascript
   console.log([] instanceof Array); // true
   console.log({} instanceof Object); // true
   ```

---

## 5. 以下代码的输出是什么？

```javascript
console.log(1 + "2"); // ?
console.log("5" - 2); // ?
```

### 答案：
1. `1 + "2"` 输出 `"12"`。
   - 因为 `+` 操作符会将数字 `1` 转为字符串。
2. `"5" - 2` 输出 `3`。
   - 因为 `-` 操作符会将字符串 `"5"` 转为数字。

---

以上是《JavaScript高级程序设计》第3章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第4章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第4章：变量、作用域与内存

## 4.1 原始值与引用值

1. **原始值**：
   - 包括：`Undefined`、`Null`、`Boolean`、`Number`、`String`、`Symbol`、`BigInt`。
   - 存储在栈内存中，按值访问。
   - 赋值时会复制值。
   - 示例：
     ```javascript
     let a = 10;
     let b = a;
     b = 20;
     console.log(a); // 10
     ```

2. **引用值**：
   - 包括：`Object`、`Array`、`Function` 等。
   - 存储在堆内存中，变量保存的是指向对象的引用地址。
   - 赋值时会复制引用地址。
   - 示例：
     ```javascript
     let obj1 = { name: "Alice" };
     let obj2 = obj1;
     obj2.name = "Bob";
     console.log(obj1.name); // "Bob"
     ```

---

## 4.2 执行上下文与作用域

1. **执行上下文**：
   - 每次函数调用或全局代码执行时都会创建一个执行上下文。
   - 包括：
     - 变量对象（Variable Object，存储变量和函数声明）。
     - 作用域链（Scope Chain，用于标识符解析）。
     - `this` 绑定。

2. **作用域**：
   - 定义变量和函数的可访问范围。
   - JavaScript 使用词法作用域（静态作用域），作用域在代码编写时确定。

3. **作用域链**：
   - 每个执行上下文都有一个作用域链，用于解析变量。
   - 查找变量时，会从当前作用域开始，逐级向上查找，直到全局作用域。

---

## 4.3 变量声明与提升

1. **变量提升**：
   - 使用 `var` 声明的变量会被提升到作用域顶部，但值为 `undefined`。
   - 示例：
     ```javascript
     console.log(a); // undefined
     var a = 10;
     ```

2. **`let` 和 `const` 的行为**：
   - 不会被提升到作用域顶部。
   - 存在**暂时性死区**（TDZ），在声明之前无法访问。
   - 示例：
     ```javascript
     console.log(b); // ReferenceError
     let b = 20;
     ```

---

## 4.4 垃圾回收与内存管理

1. **垃圾回收**：
   - JavaScript 使用自动垃圾回收机制，开发者无需手动释放内存。
   - 常用的垃圾回收算法：
     - **标记清除**：标记活动对象，清除未标记的对象。
     - **引用计数**：跟踪对象的引用次数，引用为 0 时回收。

2. **内存泄漏**：
   - 常见原因：
     - 未清除的全局变量。
     - 闭包中未释放的变量。
     - DOM 元素未正确移除。
   - 解决方法：
     - 避免使用全局变量。
     - 使用 `WeakMap` 或 `WeakSet` 存储临时对象。
     - 定期清理不再使用的引用。

---

# 第四章：经典面试题及解析

## 1. 原始值和引用值的区别是什么？

### 答案：
1. **原始值**：
   - 存储在栈内存中，按值访问。
   - 赋值时会复制值。
   - 不可变（值本身不能被修改）。

2. **引用值**：
   - 存储在堆内存中，变量保存的是引用地址。
   - 赋值时会复制引用地址。
   - 可变（对象的属性可以被修改）。

---

## 2. 以下代码的输出是什么？

```javascript
let a = 10;
let b = a;
b = 20;
console.log(a); // ?
console.log(b); // ?
```

### 答案：
1. `console.log(a)` 输出 `10`。
2. `console.log(b)` 输出 `20`。

### 解析：
- `a` 和 `b` 是原始值，赋值时会复制值，互不影响。

---

## 3. 以下代码的输出是什么？

```javascript
let obj1 = { name: "Alice" };
let obj2 = obj1;
obj2.name = "Bob";
console.log(obj1.name); // ?
```

### 答案：
`console.log(obj1.name)` 输出 `"Bob"`。

### 解析：
- `obj1` 和 `obj2` 保存的是同一个对象的引用地址，修改 `obj2.name` 会影响 `obj1.name`。

---

## 4. 什么是作用域链？如何工作？

### 答案：
- **作用域链**是由当前执行上下文的变量对象和其父级执行上下文的变量对象组成的链条。
- **工作原理**：
  - 查找变量时，JavaScript 会从当前作用域开始，逐级向上查找，直到全局作用域。
  - 如果在全局作用域中仍未找到变量，则抛出 `ReferenceError`。

---

## 5. 以下代码的输出是什么？

```javascript
var a = 10;
function test() {
  console.log(a); // ?
  var a = 20;
  console.log(a); // ?
}
test();
```

### 答案：
1. 第一个 `console.log(a)` 输出 `undefined`。
2. 第二个 `console.log(a)` 输出 `20`。

### 解析：
- 由于变量提升，`var a` 在函数作用域顶部被声明，但值为 `undefined`。
- 第二个 `console.log(a)` 输出 `20`，因为变量 `a` 已经被赋值。

---

## 6. 以下代码的输出是什么？

```javascript
let a = 10;
function test() {
  console.log(a); // ?
  let a = 20;
  console.log(a); // ?
}
test();
```

### 答案：
1. 第一个 `console.log(a)` 抛出 `ReferenceError`。
2. 第二个 `console.log(a)` 不会执行。

### 解析：
- `let` 声明的变量存在**暂时性死区**（TDZ），在声明之前无法访问。

---

## 7. 什么是垃圾回收？JavaScript 使用了哪些垃圾回收算法？

### 答案：
- **垃圾回收**是指自动释放不再使用的内存。
- **JavaScript 的垃圾回收算法**：
  1. **标记清除**：
     - 标记活动对象，清除未标记的对象。
  2. **引用计数**：
     - 跟踪对象的引用次数，引用为 0 时回收。

---

## 8. 如何避免内存泄漏？

### 答案：
1. 避免使用全局变量。
2. 使用 `WeakMap` 或 `WeakSet` 存储临时对象。
3. 在不需要时手动移除事件监听器。
4. 确保 DOM 元素被正确移除。

---

## 9. 以下代码的输出是什么？

```javascript
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}
const counter = outer();
counter(); // ?
counter(); // ?
```

### 答案：
1. 第一次调用 `counter()` 输出 `1`。
2. 第二次调用 `counter()` 输出 `2`。

### 解析：
- `inner` 函数是一个闭包，能够访问 `outer` 函数的变量 `count`。
- 每次调用 `counter()`，`count` 的值都会递增。

---

以上是《JavaScript高级程序设计》第4章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第5章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第5章：基本引用类型

## 5.1 Object 类型

1. **创建对象的方式**：
   - **对象字面量**：
     ```javascript
     let obj = {
       name: "Alice",
       age: 25,
     };
     ```
   - **`new Object()` 构造函数**：
     ```javascript
     let obj = new Object();
     obj.name = "Alice";
     obj.age = 25;
     ```

2. **访问属性**：
   - 点操作符：`obj.name`
   - 方括号操作符：`obj["name"]`

3. **删除属性**：
   - 使用 `delete` 操作符：
     ```javascript
     delete obj.name;
     ```

4. **检测属性**：
   - 使用 `in` 操作符：
     ```javascript
     console.log("name" in obj); // true
     ```
   - 使用 `hasOwnProperty()` 方法：
     ```javascript
     console.log(obj.hasOwnProperty("name")); // true
     ```

---

## 5.2 Array 类型

1. **创建数组的方式**：
   - **数组字面量**：
     ```javascript
     let arr = [1, 2, 3];
     ```
   - **`new Array()` 构造函数**：
     ```javascript
     let arr = new Array(1, 2, 3);
     ```

2. **数组的常用方法**：
   - **栈方法**：
     - `push()`：在数组末尾添加元素。
     - `pop()`：移除数组末尾的元素。
   - **队列方法**：
     - `shift()`：移除数组开头的元素。
     - `unshift()`：在数组开头添加元素。
   - **排序方法**：
     - `sort()`：对数组进行排序。
     - `reverse()`：反转数组。
   - **迭代方法**：
     - `forEach()`：对数组的每个元素执行回调函数。
     - `map()`：对数组的每个元素执行回调函数并返回新数组。
     - `filter()`：过滤数组中的元素。
     - `reduce()`：对数组中的元素进行累加。

3. **检测数组**：
   - 使用 `Array.isArray()` 方法：
     ```javascript
     console.log(Array.isArray(arr)); // true
     ```

---

## 5.3 Date 类型

1. **创建日期对象**：
   ```javascript
   let now = new Date();
   let specificDate = new Date("2025-04-10");
   ```

2. **常用方法**：
   - 获取日期和时间：
     - `getFullYear()`：获取年份。
     - `getMonth()`：获取月份（0-11）。
     - `getDate()`：获取日期。
     - `getDay()`：获取星期几（0-6）。
     - `getHours()`、`getMinutes()`、`getSeconds()`：获取时间。
   - 设置日期和时间：
     - `setFullYear()`、`setMonth()`、`setDate()` 等。

---

## 5.4 RegExp 类型

1. **创建正则表达式**：
   - 字面量方式：
     ```javascript
     let regex = /abc/;
     ```
   - 构造函数方式：
     ```javascript
     let regex = new RegExp("abc");
     ```

2. **常用方法**：
   - `test()`：测试字符串是否匹配正则表达式。
     ```javascript
     console.log(/abc/.test("abcdef")); // true
     ```
   - `exec()`：返回匹配的详细信息。
     ```javascript
     let result = /abc/.exec("abcdef");
     console.log(result[0]); // "abc"
     ```

3. **正则表达式标志**：
   - `g`：全局匹配。
   - `i`：忽略大小写。
   - `m`：多行匹配。

---

## 5.5 Function 类型

1. **函数声明**：
   ```javascript
   function add(a, b) {
     return a + b;
   }
   ```

2. **函数表达式**：
   ```javascript
   const add = function (a, b) {
     return a + b;
   };
   ```

3. **箭头函数**（ES6）：
   ```javascript
   const add = (a, b) => a + b;
   ```

4. **函数的属性和方法**：
   - `length`：函数的参数个数。
   - `call()` 和 `apply()`：改变函数的 `this` 指向并调用函数。
   - `bind()`：返回一个绑定了 `this` 的新函数。

---

## 5.6 单体内置对象

1. **Global 对象**：
   - 全局作用域中的对象。
   - 常用方法：
     - `parseInt()` 和 `parseFloat()`：将字符串转换为数字。
     - `isNaN()`：检测是否为非数字。
     - `isFinite()`：检测是否为有限数值。

2. **Math 对象**：
   - 常用方法：
     - `Math.random()`：生成 0 到 1 之间的随机数。
     - `Math.floor()`、`Math.ceil()`、`Math.round()`：向下取整、向上取整、四舍五入。
     - `Math.max()` 和 `Math.min()`：获取最大值和最小值。

---

# 第五章：经典面试题及解析

## 1. 如何检测一个变量是否是数组？

### 答案：
使用 `Array.isArray()` 方法：
```javascript
let arr = [1, 2, 3];
console.log(Array.isArray(arr)); // true
```

---

## 2. 以下代码的输出是什么？

```javascript
let obj1 = { name: "Alice" };
let obj2 = obj1;
obj2.name = "Bob";
console.log(obj1.name); // ?
```

### 答案：
`console.log(obj1.name)` 输出 `"Bob"`。

### 解析：
- `obj1` 和 `obj2` 保存的是同一个对象的引用地址，修改 `obj2.name` 会影响 `obj1.name`。

---

## 3. 以下代码的输出是什么？

```javascript
let arr = [1, 2, 3];
arr.push(4);
console.log(arr); // ?
arr.pop();
console.log(arr); // ?
```

### 答案：
1. 第一个 `console.log(arr)` 输出 `[1, 2, 3, 4]`。
2. 第二个 `console.log(arr)` 输出 `[1, 2, 3]`。

### 解析：
- `push()` 方法在数组末尾添加元素。
- `pop()` 方法移除数组末尾的元素。

---

## 4. 如何生成一个 1 到 100 的随机整数？

### 答案：
使用 `Math.random()` 和 `Math.floor()`：
```javascript
let randomInt = Math.floor(Math.random() * 100) + 1;
console.log(randomInt);
```

---

## 5. 以下代码的输出是什么？

```javascript
let regex = /hello/i;
console.log(regex.test("Hello, world!")); // ?
```

### 答案：
`console.log(regex.test("Hello, world!"))` 输出 `true`。

### 解析：
- 正则表达式 `/hello/i` 中的 `i` 标志表示忽略大小写匹配。

---

## 6. 以下代码的输出是什么？

```javascript
function add(a, b) {
  return a + b;
}
console.log(add.length); // ?
```

### 答案：
`console.log(add.length)` 输出 `2`。

### 解析：
- 函数的 `length` 属性表示函数的形参个数。

---

## 7. 如何使用 `call()` 和 `apply()` 改变函数的 `this` 指向？

### 答案：
使用 `call()` 或 `apply()`：
```javascript
function greet() {
  console.log(`Hello, ${this.name}`);
}
let person = { name: "Alice" };
greet.call(person); // "Hello, Alice"
greet.apply(person); // "Hello, Alice"
```

---

以上是《JavaScript高级程序设计》第5章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第6章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第6章：集合引用类型

## 6.1 集合类型概述

- 集合引用类型是 ECMAScript 6（ES6）引入的新特性，用于存储和操作集合数据。
- 包括：
  - **`Set`**：存储唯一值的集合。
  - **`WeakSet`**：存储弱引用的对象集合。
  - **`Map`**：键值对的集合。
  - **`WeakMap`**：存储弱引用键值对的集合。

---

## 6.2 Set 类型

1. **定义**：
   - `Set` 是一种集合类型，用于存储唯一值（不重复的值）。

2. **创建 Set**：
   ```javascript
   let set = new Set([1, 2, 3, 3]);
   console.log(set); // Set { 1, 2, 3 }
   ```

3. **常用方法**：
   - `add(value)`：向集合中添加值。
   - `delete(value)`：删除集合中的值。
   - `has(value)`：检查集合中是否存在某个值。
   - `clear()`：清空集合。
   - `size`：返回集合的大小。

   示例：
   ```javascript
   let set = new Set();
   set.add(1);
   set.add(2);
   console.log(set.has(1)); // true
   set.delete(1);
   console.log(set.size); // 1
   ```

4. **遍历 Set**：
   - 使用 `for...of`：
     ```javascript
     for (let value of set) {
       console.log(value);
     }
     ```
   - 使用 `forEach()`：
     ```javascript
     set.forEach(value => console.log(value));
     ```

---

## 6.3 WeakSet 类型

1. **定义**：
   - `WeakSet` 是一种集合类型，用于存储**对象的弱引用**。
   - 弱引用不会阻止垃圾回收。

2. **特点**：
   - 只能存储对象（不能存储原始值）。
   - 没有 `size` 属性，也不可遍历。

3. **常用方法**：
   - `add(value)`：向集合中添加对象。
   - `delete(value)`：删除集合中的对象。
   - `has(value)`：检查集合中是否存在某个对象。

   示例：
   ```javascript
   let weakSet = new WeakSet();
   let obj = { name: "Alice" };
   weakSet.add(obj);
   console.log(weakSet.has(obj)); // true
   weakSet.delete(obj);
   console.log(weakSet.has(obj)); // false
   ```

---

## 6.4 Map 类型

1. **定义**：
   - `Map` 是一种键值对集合，键可以是任意类型。

2. **创建 Map**：
   ```javascript
   let map = new Map([
     ["name", "Alice"],
     ["age", 25],
   ]);
   console.log(map); // Map { 'name' => 'Alice', 'age' => 25 }
   ```

3. **常用方法**：
   - `set(key, value)`：设置键值对。
   - `get(key)`：获取键对应的值。
   - `has(key)`：检查是否存在某个键。
   - `delete(key)`：删除键值对。
   - `clear()`：清空集合。
   - `size`：返回集合的大小。

   示例：
   ```javascript
   let map = new Map();
   map.set("name", "Alice");
   console.log(map.get("name")); // "Alice"
   console.log(map.has("name")); // true
   map.delete("name");
   console.log(map.size); // 0
   ```

4. **遍历 Map**：
   - 使用 `for...of`：
     ```javascript
     for (let [key, value] of map) {
       console.log(key, value);
     }
     ```
   - 使用 `forEach()`：
     ```javascript
     map.forEach((value, key) => console.log(key, value));
     ```

---

## 6.5 WeakMap 类型

1. **定义**：
   - `WeakMap` 是一种键值对集合，键必须是对象，值可以是任意类型。
   - 键是弱引用，不会阻止垃圾回收。

2. **特点**：
   - 只能使用对象作为键。
   - 没有 `size` 属性，也不可遍历。

3. **常用方法**：
   - `set(key, value)`：设置键值对。
   - `get(key)`：获取键对应的值。
   - `has(key)`：检查是否存在某个键。
   - `delete(key)`：删除键值对。

   示例：
   ```javascript
   let weakMap = new WeakMap();
   let obj = { name: "Alice" };
   weakMap.set(obj, "some value");
   console.log(weakMap.get(obj)); // "some value"
   weakMap.delete(obj);
   console.log(weakMap.has(obj)); // false
   ```

---

# 第六章：经典面试题及解析

## 1. `Set` 和 `WeakSet` 的区别是什么？

### 答案：
1. **`Set`**：
   - 可以存储任意类型的值（包括原始值和对象）。
   - 支持 `size` 属性和遍历操作。
   - 存储的是强引用。

2. **`WeakSet`**：
   - 只能存储对象。
   - 不支持 `size` 属性和遍历操作。
   - 存储的是弱引用，键对象可以被垃圾回收。

---

## 2. `Map` 和 `WeakMap` 的区别是什么？

### 答案：
1. **`Map`**：
   - 键可以是任意类型（包括原始值和对象）。
   - 支持 `size` 属性和遍历操作。
   - 存储的是强引用。

2. **`WeakMap`**：
   - 键必须是对象。
   - 不支持 `size` 属性和遍历操作。
   - 存储的是弱引用，键对象可以被垃圾回收。

---

## 3. 以下代码的输出是什么？

```javascript
let set = new Set();
set.add(1);
set.add(2);
set.add(1);
console.log(set.size); // ?
```

### 答案：
`console.log(set.size)` 输出 `2`。

### 解析：
- `Set` 中的值是唯一的，重复添加的值会被忽略。

---

## 4. 以下代码的输出是什么？

```javascript
let map = new Map();
map.set("name", "Alice");
map.set("age", 25);
console.log(map.get("name")); // ?
console.log(map.has("age")); // ?
console.log(map.size); // ?
```

### 答案：
1. `console.log(map.get("name"))` 输出 `"Alice"`。
2. `console.log(map.has("age"))` 输出 `true`。
3. `console.log(map.size)` 输出 `2`。

---

## 5. 如何使用 `WeakMap` 存储私有数据？

### 答案：
可以使用 `WeakMap` 存储对象的私有数据，因为键是弱引用，外部无法直接访问。

### 示例：
```javascript
const privateData = new WeakMap();

class Person {
  constructor(name) {
    privateData.set(this, { name });
  }

  getName() {
    return privateData.get(this).name;
  }
}

const person = new Person("Alice");
console.log(person.getName()); // "Alice"
```

---

## 6. 以下代码的输出是什么？

```javascript
let weakSet = new WeakSet();
let obj = { name: "Alice" };
weakSet.add(obj);
console.log(weakSet.has(obj)); // ?
weakSet.delete(obj);
console.log(weakSet.has(obj)); // ?
```

### 答案：
1. `console.log(weakSet.has(obj))` 输出 `true`。
2. `console.log(weakSet.has(obj))` 输出 `false`。

### 解析：
- `WeakSet` 存储的是对象的弱引用，删除后无法再访问。

---

以上是《JavaScript高级程序设计》第6章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第7章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第7章：迭代器与生成器

## 7.1 迭代器模式

1. **定义**：
   - 迭代器是一种设计模式，用于按顺序访问集合中的元素，而不暴露集合的内部结构。

2. **迭代器的核心方法**：
   - `next()`：返回集合中的下一个值。
     - 返回值是一个对象，包含两个属性：
       - `value`：当前的值。
       - `done`：布尔值，表示是否迭代完成。

3. **示例**：
   ```javascript
   function createIterator(array) {
     let index = 0;
     return {
       next: function () {
         return index < array.length
           ? { value: array[index++], done: false }
           : { value: undefined, done: true };
       },
     };
   }
   
   const iterator = createIterator([1, 2, 3]);
   console.log(iterator.next()); // { value: 1, done: false }
   console.log(iterator.next()); // { value: 2, done: false }
   console.log(iterator.next()); // { value: 3, done: false }
   console.log(iterator.next()); // { value: undefined, done: true }
   ```

---

## 7.2 可迭代对象

1. **定义**：
   - 可迭代对象是实现了 `@@iterator` 方法（即 `Symbol.iterator` 属性）的对象。

2. **内置可迭代对象**：
   - 数组、字符串、`Map`、`Set`、`arguments` 对象、`NodeList` 等。

3. **自定义可迭代对象**：
   ```javascript
   const iterable = {
     [Symbol.iterator]: function () {
       let step = 0;
       return {
         next: function () {
           step++;
           if (step <= 3) {
             return { value: step, done: false };
           } else {
             return { value: undefined, done: true };
           }
         },
       };
     },
   };
   
   for (const value of iterable) {
     console.log(value); // 1, 2, 3
   }
   ```

---

## 7.3 for...of 循环

1. **定义**：
   - `for...of` 是 ES6 引入的一种循环语法，用于遍历可迭代对象。

2. **与 for...in 的区别**：
   - `for...in` 遍历对象的**可枚举属性**（包括原型链上的属性）。
   - `for...of` 遍历可迭代对象的值。

3. **示例**：
   ```javascript
   const array = [1, 2, 3];
   for (const value of array) {
     console.log(value); // 1, 2, 3
   }
   ```

---

## 7.4 生成器（Generator）

1. **定义**：
   - 生成器是一个返回迭代器的函数，使用 `function*` 定义。
   - 生成器函数可以通过 `yield` 暂停执行，并通过 `next()` 恢复执行。

2. **语法**：
   ```javascript
   function* generatorFunction() {
     yield 1;
     yield 2;
     yield 3;
   }
   
   const generator = generatorFunction();
   console.log(generator.next()); // { value: 1, done: false }
   console.log(generator.next()); // { value: 2, done: false }
   console.log(generator.next()); // { value: 3, done: false }
   console.log(generator.next()); // { value: undefined, done: true }
   ```

3. **生成器的特点**：
   - 可以暂停和恢复执行。
   - 每次调用 `next()`，生成器函数会从上次暂停的地方继续执行。

4. **生成器的应用场景**：
   - 延迟执行。
   - 异步编程（与 `async/await` 配合使用）。
   - 无限数据流。

---

## 7.5 异步迭代器

1. **定义**：
   - 异步迭代器是支持异步操作的迭代器，使用 `for await...of` 遍历。

2. **示例**：
   ```javascript
   async function* asyncGenerator() {
     yield "Hello";
     yield "World";
   }
   
   (async () => {
     for await (const value of asyncGenerator()) {
       console.log(value); // "Hello", "World"
     }
   })();
   ```

---

# 第七章：经典面试题及解析

## 1. 什么是迭代器？如何实现一个简单的迭代器？

### 答案：
- **迭代器**是一种对象，用于按顺序访问集合中的元素。
- 迭代器对象必须实现 `next()` 方法，返回一个包含 `value` 和 `done` 属性的对象。

### 示例：
```javascript
function createIterator(array) {
  let index = 0;
  return {
    next: function () {
      return index < array.length
        ? { value: array[index++], done: false }
        : { value: undefined, done: true };
    },
  };
}

const iterator = createIterator([1, 2, 3]);
console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

---

## 2. 什么是生成器？生成器与普通函数的区别是什么？

### 答案：
- **生成器**是一个返回迭代器的函数，使用 `function*` 定义。
- **区别**：
  1. 生成器可以暂停和恢复执行，而普通函数一旦开始执行就会运行到底。
  2. 生成器使用 `yield` 暂停执行，普通函数没有类似的机制。

### 示例：
```javascript
function* generatorFunction() {
  yield 1;
  yield 2;
  yield 3;
}

const generator = generatorFunction();
console.log(generator.next()); // { value: 1, done: false }
console.log(generator.next()); // { value: 2, done: false }
console.log(generator.next()); // { value: 3, done: false }
console.log(generator.next()); // { value: undefined, done: true }
```

---

## 3. 以下代码的输出是什么？

```javascript
const array = [1, 2, 3];
for (const value of array) {
  console.log(value);
}
```

### 答案：
输出：
```
1
2
3
```

### 解析：
- `for...of` 遍历可迭代对象的值。
- 数组是内置的可迭代对象。

---

## 4. 如何自定义一个可迭代对象？

### 答案：
通过实现 `Symbol.iterator` 方法来自定义可迭代对象。

### 示例：
```javascript
const iterable = {
  [Symbol.iterator]: function () {
    let step = 0;
    return {
      next: function () {
        step++;
        if (step <= 3) {
          return { value: step, done: false };
        } else {
          return { value: undefined, done: true };
        }
      },
    };
  },
};

for (const value of iterable) {
  console.log(value); // 1, 2, 3
}
```

---

## 5. 以下代码的输出是什么？

```javascript
function* generatorFunction() {
  yield 1;
  yield 2;
  return 3;
}

const generator = generatorFunction();
console.log(generator.next()); // ?
console.log(generator.next()); // ?
console.log(generator.next()); // ?
console.log(generator.next()); // ?
```

### 答案：
输出：
```
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: true }
{ value: undefined, done: true }
```

### 解析：
- 第一次调用 `next()`，生成器返回第一个 `yield` 的值。
- 第二次调用 `next()`，生成器返回第二个 `yield` 的值。
- 第三次调用 `next()`，生成器返回 `return` 的值，并将 `done` 设置为 `true`。
- 第四次调用 `next()`，生成器已完成，返回 `{ value: undefined, done: true }`。

---

## 6. 什么是异步迭代器？如何使用 `for await...of`？

### 答案：
- **异步迭代器**是支持异步操作的迭代器。
- 使用 `for await...of` 遍历异步迭代器。

### 示例：
```javascript
async function* asyncGenerator() {
  yield "Hello";
  yield "World";
}

(async () => {
  for await (const value of asyncGenerator()) {
    console.log(value); // "Hello", "World"
  }
})();
```

---

以上是《JavaScript高级程序设计》第7章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第8章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第8章：对象、类与面向对象编程

## 8.1 理解对象

1. **对象的定义**：
   - 对象是属性的集合，属性可以包含基本值、对象或函数。

2. **创建对象的方式**：
   - **对象字面量**：
     ```javascript
     let obj = {
       name: "Alice",
       age: 25,
       greet: function () {
         console.log("Hello!");
       },
     };
     ```
   - **`new Object()` 构造函数**：
     ```javascript
     let obj = new Object();
     obj.name = "Alice";
     obj.age = 25;
     ```

3. **属性类型**：
   - 数据属性：包含一个值。
   - 访问器属性：通过 `getter` 和 `setter` 访问值。

4. **属性描述符**：
   - 使用 `Object.defineProperty()` 定义属性的特性：
     - `configurable`：是否可以删除或修改属性。
     - `enumerable`：是否可以通过 `for...in` 遍历。
     - `writable`：是否可以修改属性值。
     - `value`：属性的值。

   示例：
   ```javascript
   let obj = {};
   Object.defineProperty(obj, "name", {
     value: "Alice",
     writable: false,
     configurable: true,
     enumerable: true,
   });
   console.log(obj.name); // "Alice"
   obj.name = "Bob"; // 无法修改，因为 writable 为 false
   ```

---

## 8.2 原型与继承

1. **原型链**：
   - 每个对象都有一个内部属性 `[[Prototype]]`，指向其原型对象。
   - 原型对象也可以有自己的原型，形成原型链。
   - 查找属性时，会沿着原型链向上查找，直到找到属性或到达 `null`。

2. **`Object.create()`**：
   - 创建一个以指定对象为原型的新对象。
   - 示例：
     ```javascript
     let parent = { name: "Alice" };
     let child = Object.create(parent);
     console.log(child.name); // "Alice"
     ```

3. **`__proto__` 与 `Object.getPrototypeOf()`**：
   - `__proto__`：访问对象的原型（不推荐使用）。
   - `Object.getPrototypeOf(obj)`：获取对象的原型。

---

## 8.3 类与类继承（ES6）

1. **类的定义**：
   - 使用 `class` 关键字定义类。
   - 示例：
     ```javascript
     class Person {
       constructor(name, age) {
         this.name = name;
         this.age = age;
       }
     
       greet() {
         console.log(`Hello, my name is ${this.name}`);
       }
     }
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

2. **类的继承**：
   - 使用 `extends` 关键字实现继承。
   - 子类必须调用 `super()` 方法以访问父类的构造函数。
   - 示例：
     ```javascript
     class Animal {
       constructor(name) {
         this.name = name;
       }
     
       speak() {
         console.log(`${this.name} makes a noise.`);
       }
     }
     
     class Dog extends Animal {
       speak() {
         console.log(`${this.name} barks.`);
       }
     }
     
     const dog = new Dog("Rex");
     dog.speak(); // "Rex barks."
     ```

3. **静态方法**：
   - 使用 `static` 关键字定义静态方法，静态方法只能通过类调用，不能通过实例调用。
   - 示例：
     ```javascript
     class MathUtils {
       static add(a, b) {
         return a + b;
       }
     }
     
     console.log(MathUtils.add(2, 3)); // 5
     ```

---

## 8.4 面向对象编程的实现方式

1. **工厂模式**：
   - 使用函数创建对象并返回。
   - 示例：
     ```javascript
     function createPerson(name, age) {
       return {
         name,
         age,
         greet() {
           console.log(`Hello, my name is ${name}`);
         },
       };
     }
     
     const person = createPerson("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

2. **构造函数模式**：
   - 使用构造函数创建对象。
   - 示例：
     ```javascript
     function Person(name, age) {
       this.name = name;
       this.age = age;
       this.greet = function () {
         console.log(`Hello, my name is ${this.name}`);
       };
     }
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

3. **原型模式**：
   - 将方法定义在构造函数的原型上，所有实例共享这些方法。
   - 示例：
     ```javascript
     function Person(name, age) {
       this.name = name;
       this.age = age;
     }
     
     Person.prototype.greet = function () {
       console.log(`Hello, my name is ${this.name}`);
     };
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

4. **组合模式**：
   - 将构造函数模式和原型模式结合使用。
   - 示例：
     ```javascript
     function Person(name, age) {
       this.name = name;
       this.age = age;
     }
     
     Person.prototype.greet = function () {
       console.log(`Hello, my name is ${this.name}`);
     };
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

---

# 第八章：经典面试题及解析

## 1. 什么是原型链？如何实现继承？

### 答案：
- **原型链**是对象的继承机制，每个对象都有一个内部属性 `[[Prototype]]`，指向其原型对象。
- **实现继承**：
  - 使用 `Object.create()`：
    ```javascript
    let parent = { name: "Alice" };
    let child = Object.create(parent);
    console.log(child.name); // "Alice"
    ```

---

## 2. 以下代码的输出是什么？

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function () {
  console.log(`Hello, my name is ${this.name}`);
};

const person = new Person("Alice");
person.greet();
```

### 答案：
输出：
```
Hello, my name is Alice
```

### 解析：
- `greet` 方法定义在 `Person.prototype` 上，所有实例共享该方法。

---

## 3. 如何使用 ES6 类实现继承？

### 答案：
使用 `class` 和 `extends` 关键字实现继承。

### 示例：
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks.`);
  }
}

const dog = new Dog("Rex");
dog.speak(); // "Rex barks."
```

---

## 4. 以下代码的输出是什么？

```javascript
class Parent {
  constructor() {
    this.name = "Parent";
  }
}

class Child extends Parent {
  constructor() {
    super();
    this.name = "Child";
  }
}

const child = new Child();
console.log(child.name);
```

### 答案：
输出：
```
Child
```

### 解析：
- 子类的构造函数必须调用 `super()`，以访问父类的构造函数。
- 子类的 `this.name` 覆盖了父类的 `this.name`。

---

## 5. 什么是静态方法？如何定义和使用？

### 答案：
- **静态方法**是定义在类上的方法，不能通过实例调用，只能通过类调用。
- 使用 `static` 关键字定义。

### 示例：
```javascript
class MathUtils {
  static add(a, b) {
    return a + b;
  }
}

console.log(MathUtils.add(2, 3)); // 5
```

---

以上是《JavaScript高级程序设计》第8章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第8章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第8章：对象、类与面向对象编程

## 8.1 理解对象

1. **对象的定义**：
   - 对象是属性的集合，属性可以包含基本值、对象或函数。

2. **创建对象的方式**：
   - **对象字面量**：
     ```javascript
     let obj = {
       name: "Alice",
       age: 25,
       greet: function () {
         console.log("Hello!");
       },
     };
     ```
   - **`new Object()` 构造函数**：
     ```javascript
     let obj = new Object();
     obj.name = "Alice";
     obj.age = 25;
     ```

3. **属性类型**：
   - 数据属性：包含一个值。
   - 访问器属性：通过 `getter` 和 `setter` 访问值。

4. **属性描述符**：
   - 使用 `Object.defineProperty()` 定义属性的特性：
     - `configurable`：是否可以删除或修改属性。
     - `enumerable`：是否可以通过 `for...in` 遍历。
     - `writable`：是否可以修改属性值。
     - `value`：属性的值。

   示例：
   ```javascript
   let obj = {};
   Object.defineProperty(obj, "name", {
     value: "Alice",
     writable: false,
     configurable: true,
     enumerable: true,
   });
   console.log(obj.name); // "Alice"
   obj.name = "Bob"; // 无法修改，因为 writable 为 false
   ```

---

## 8.2 原型与继承

1. **原型链**：
   - 每个对象都有一个内部属性 `[[Prototype]]`，指向其原型对象。
   - 原型对象也可以有自己的原型，形成原型链。
   - 查找属性时，会沿着原型链向上查找，直到找到属性或到达 `null`。

2. **`Object.create()`**：
   - 创建一个以指定对象为原型的新对象。
   - 示例：
     ```javascript
     let parent = { name: "Alice" };
     let child = Object.create(parent);
     console.log(child.name); // "Alice"
     ```

3. **`__proto__` 与 `Object.getPrototypeOf()`**：
   - `__proto__`：访问对象的原型（不推荐使用）。
   - `Object.getPrototypeOf(obj)`：获取对象的原型。

---

## 8.3 类与类继承（ES6）

1. **类的定义**：
   - 使用 `class` 关键字定义类。
   - 示例：
     ```javascript
     class Person {
       constructor(name, age) {
         this.name = name;
         this.age = age;
       }
     
       greet() {
         console.log(`Hello, my name is ${this.name}`);
       }
     }
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

2. **类的继承**：
   - 使用 `extends` 关键字实现继承。
   - 子类必须调用 `super()` 方法以访问父类的构造函数。
   - 示例：
     ```javascript
     class Animal {
       constructor(name) {
         this.name = name;
       }
     
       speak() {
         console.log(`${this.name} makes a noise.`);
       }
     }
     
     class Dog extends Animal {
       speak() {
         console.log(`${this.name} barks.`);
       }
     }
     
     const dog = new Dog("Rex");
     dog.speak(); // "Rex barks."
     ```

3. **静态方法**：
   - 使用 `static` 关键字定义静态方法，静态方法只能通过类调用，不能通过实例调用。
   - 示例：
     ```javascript
     class MathUtils {
       static add(a, b) {
         return a + b;
       }
     }
     
     console.log(MathUtils.add(2, 3)); // 5
     ```

---

## 8.4 面向对象编程的实现方式

1. **工厂模式**：
   - 使用函数创建对象并返回。
   - 示例：
     ```javascript
     function createPerson(name, age) {
       return {
         name,
         age,
         greet() {
           console.log(`Hello, my name is ${name}`);
         },
       };
     }
     
     const person = createPerson("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

2. **构造函数模式**：
   - 使用构造函数创建对象。
   - 示例：
     ```javascript
     function Person(name, age) {
       this.name = name;
       this.age = age;
       this.greet = function () {
         console.log(`Hello, my name is ${this.name}`);
       };
     }
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

3. **原型模式**：
   - 将方法定义在构造函数的原型上，所有实例共享这些方法。
   - 示例：
     ```javascript
     function Person(name, age) {
       this.name = name;
       this.age = age;
     }
     
     Person.prototype.greet = function () {
       console.log(`Hello, my name is ${this.name}`);
     };
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

4. **组合模式**：
   - 将构造函数模式和原型模式结合使用。
   - 示例：
     ```javascript
     function Person(name, age) {
       this.name = name;
       this.age = age;
     }
     
     Person.prototype.greet = function () {
       console.log(`Hello, my name is ${this.name}`);
     };
     
     const person = new Person("Alice", 25);
     person.greet(); // "Hello, my name is Alice"
     ```

---

# 第八章：经典面试题及解析

## 1. 什么是原型链？如何实现继承？

### 答案：
- **原型链**是对象的继承机制，每个对象都有一个内部属性 `[[Prototype]]`，指向其原型对象。
- **实现继承**：
  - 使用 `Object.create()`：
    ```javascript
    let parent = { name: "Alice" };
    let child = Object.create(parent);
    console.log(child.name); // "Alice"
    ```

---

## 2. 以下代码的输出是什么？

```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function () {
  console.log(`Hello, my name is ${this.name}`);
};

const person = new Person("Alice");
person.greet();
```

### 答案：
输出：
```
Hello, my name is Alice
```

### 解析：
- `greet` 方法定义在 `Person.prototype` 上，所有实例共享该方法。

---

## 3. 如何使用 ES6 类实现继承？

### 答案：
使用 `class` 和 `extends` 关键字实现继承。

### 示例：
```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} barks.`);
  }
}

const dog = new Dog("Rex");
dog.speak(); // "Rex barks."
```

---

## 4. 以下代码的输出是什么？

```javascript
class Parent {
  constructor() {
    this.name = "Parent";
  }
}

class Child extends Parent {
  constructor() {
    super();
    this.name = "Child";
  }
}

const child = new Child();
console.log(child.name);
```

### 答案：
输出：
```
Child
```

### 解析：
- 子类的构造函数必须调用 `super()`，以访问父类的构造函数。
- 子类的 `this.name` 覆盖了父类的 `this.name`。

---

## 5. 什么是静态方法？如何定义和使用？

### 答案：
- **静态方法**是定义在类上的方法，不能通过实例调用，只能通过类调用。
- 使用 `static` 关键字定义。

### 示例：
```javascript
class MathUtils {
  static add(a, b) {
    return a + b;
  }
}

console.log(MathUtils.add(2, 3)); // 5
```

---

以上是《JavaScript高级程序设计》第8章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第10章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第10章：函数

## 10.1 函数的定义

1. **函数声明**：
   - 使用 `function` 关键字定义函数。
   - 示例：
     ```javascript
     function add(a, b) {
       return a + b;
     }
     ```

2. **函数表达式**：
   - 将函数赋值给变量。
   - 示例：
     ```javascript
     const add = function (a, b) {
       return a + b;
     };
     ```

3. **箭头函数**（ES6）：
   - 使用 `=>` 定义函数。
   - 示例：
     ```javascript
     const add = (a, b) => a + b;
     ```

---

## 10.2 函数的参数

1. **默认参数**（ES6）：
   - 为函数参数设置默认值。
   - 示例：
     ```javascript
     function greet(name = "Guest") {
       console.log(`Hello, ${name}`);
     }
     greet(); // "Hello, Guest"
     ```

2. **剩余参数**（Rest 参数，ES6）：
   - 使用 `...` 收集剩余参数为数组。
   - 示例：
     ```javascript
     function sum(...numbers) {
       return numbers.reduce((total, num) => total + num, 0);
     }
     console.log(sum(1, 2, 3)); // 6
     ```

3. **参数传递**：
   - **按值传递**：原始值作为参数传递时，函数内的修改不会影响外部变量。
   - **按引用传递**：引用值作为参数传递时，函数内的修改会影响外部对象。

---

## 10.3 函数的属性与方法

1. **`length` 属性**：
   - 返回函数的形参个数。
   - 示例：
     ```javascript
     function add(a, b) {}
     console.log(add.length); // 2
     ```

2. **`call()` 和 `apply()` 方法**：
   - 用于改变函数的 `this` 指向并调用函数。
   - 区别：
     - `call()`：参数逐个传递。
     - `apply()`：参数以数组形式传递。
   - 示例：
     ```javascript
     function greet(greeting) {
       console.log(`${greeting}, ${this.name}`);
     }
     const person = { name: "Alice" };
     greet.call(person, "Hello"); // "Hello, Alice"
     greet.apply(person, ["Hi"]); // "Hi, Alice"
     ```

3. **`bind()` 方法**：
   - 返回一个绑定了 `this` 的新函数。
   - 示例：
     ```javascript
     const person = { name: "Alice" };
     function greet() {
       console.log(`Hello, ${this.name}`);
     }
     const boundGreet = greet.bind(person);
     boundGreet(); // "Hello, Alice"
     ```

---

## 10.4 闭包

1. **定义**：
   - 闭包是指函数可以访问其外部作用域的变量，即使该函数在外部作用域之外执行。

2. **示例**：
   ```javascript
   function outer() {
     let count = 0;
     return function inner() {
       count++;
       console.log(count);
     };
   }
   
   const counter = outer();
   counter(); // 1
   counter(); // 2
   ```

3. **应用场景**：
   - 数据封装。
   - 模拟私有变量。
   - 函数柯里化。

---

## 10.5 函数柯里化

1. **定义**：
   - 柯里化是将一个多参数函数转换为一系列单参数函数的过程。

2. **示例**：
   ```javascript
   function curry(fn) {
     return function curried(...args) {
       if (args.length >= fn.length) {
         return fn(...args);
       } else {
         return (...nextArgs) => curried(...args, ...nextArgs);
       }
     };
   }
   
   function add(a, b, c) {
     return a + b + c;
   }
   
   const curriedAdd = curry(add);
   console.log(curriedAdd(1)(2)(3)); // 6
   ```

---

## 10.6 立即调用的函数表达式（IIFE）

1. **定义**：
   - IIFE 是一个立即执行的函数表达式，定义后立即调用。

2. **语法**：
   ```javascript
   (function () {
     console.log("IIFE executed");
   })();
   ```

3. **应用场景**：
   - 创建独立的作用域，避免变量污染全局作用域。

---

## 10.7 尾调用优化

1. **定义**：
   - 尾调用是指函数的最后一步是调用另一个函数。
   - 在严格模式下，尾调用可以优化为不占用额外的调用栈。

2. **示例**：
   ```javascript
   function factorial(n, acc = 1) {
     if (n === 0) return acc;
     return factorial(n - 1, acc * n); // 尾调用
   }
   console.log(factorial(5)); // 120
   ```

---

# 第十章：经典面试题及解析

## 1. 什么是闭包？闭包的应用场景有哪些？

### 答案：
- **闭包**是指函数可以访问其外部作用域的变量，即使该函数在外部作用域之外执行。
- **应用场景**：
  1. 数据封装。
  2. 模拟私有变量。
  3. 函数柯里化。

### 示例：
```javascript
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}

const counter = outer();
counter(); // 1
counter(); // 2
```

---

## 2. 以下代码的输出是什么？

```javascript
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  };
}

const counter1 = outer();
const counter2 = outer();

counter1(); // ?
counter1(); // ?
counter2(); // ?
```

### 答案：
输出：
```
1
2
1
```

### 解析：
- 每次调用 `outer()` 都会创建一个新的闭包，`counter1` 和 `counter2` 是独立的。

---

## 3. 如何使用 `call()` 和 `apply()` 改变函数的 `this` 指向？

### 答案：
- 使用 `call()` 或 `apply()` 方法可以改变函数的 `this` 指向。

### 示例：
```javascript
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

const person = { name: "Alice" };
greet.call(person, "Hello"); // "Hello, Alice"
greet.apply(person, ["Hi"]); // "Hi, Alice"
```

---

## 4. 以下代码的输出是什么？

```javascript
const person = { name: "Alice" };

function greet() {
  console.log(`Hello, ${this.name}`);
}

const boundGreet = greet.bind(person);
boundGreet();
```

### 答案：
输出：
```
Hello, Alice
```

### 解析：
- `bind()` 方法返回一个绑定了 `this` 的新函数，`this` 指向 `person`。

---

## 5. 什么是函数柯里化？如何实现一个简单的柯里化函数？

### 答案：
- **函数柯里化**是将一个多参数函数转换为一系列单参数函数的过程。

### 示例：
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    } else {
      return (...nextArgs) => curried(...args, ...nextArgs);
    }
  };
}

function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
```

---

## 6. 以下代码的输出是什么？

```javascript
(function () {
  var a = 10;
  console.log(a);
})();
console.log(a);
```

### 答案：
输出：
```
10
ReferenceError: a is not defined
```

### 解析：
- IIFE 创建了一个独立的作用域，`a` 是局部变量，无法在外部访问。

---

以上是《JavaScript高级程序设计》第10章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第11章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第11章：期约与异步函数

## 11.1 异步编程的背景

1. **异步编程的必要性**：
   - JavaScript 是单线程的，异步编程可以避免阻塞主线程。
   - 常见的异步操作：
     - 定时器（`setTimeout`、`setInterval`）。
     - 网络请求（`XMLHttpRequest`、`fetch`）。
     - 文件操作（Node.js 中的文件系统 API）。

2. **传统的异步处理方式**：
   - **回调函数**：
     - 缺点：容易导致回调地狱，代码难以维护。
     ```javascript
     setTimeout(() => {
       console.log("Step 1");
       setTimeout(() => {
         console.log("Step 2");
         setTimeout(() => {
           console.log("Step 3");
         }, 1000);
       }, 1000);
     }, 1000);
     ```

---

## 11.2 Promise

1. **定义**：
   - `Promise` 是 ES6 引入的一种异步编程解决方案，用于更优雅地处理异步操作。

2. **状态**：
   - `Promise` 有三种状态：
     - `pending`（进行中）。
     - `fulfilled`（已成功）。
     - `rejected`（已失败）。

3. **基本用法**：
   ```javascript
   const promise = new Promise((resolve, reject) => {
     const success = true;
     if (success) {
       resolve("Operation succeeded");
     } else {
       reject("Operation failed");
     }
   });
   
   promise
     .then((result) => {
       console.log(result); // "Operation succeeded"
     })
     .catch((error) => {
       console.error(error);
     });
   ```

4. **链式调用**：
   - `then()` 方法返回一个新的 `Promise`，可以链式调用。
   ```javascript
   const promise = new Promise((resolve) => resolve(1));
   
   promise
     .then((value) => {
       console.log(value); // 1
       return value + 1;
     })
     .then((value) => {
       console.log(value); // 2
       return value + 1;
     })
     .then((value) => {
       console.log(value); // 3
     });
   ```

5. **`Promise.all()`**：
   - 接受一个 `Promise` 数组，所有 `Promise` 都成功时返回结果数组。
   - 如果有一个 `Promise` 失败，则返回失败的原因。
   ```javascript
   const p1 = Promise.resolve(1);
   const p2 = Promise.resolve(2);
   const p3 = Promise.resolve(3);
   
   Promise.all([p1, p2, p3]).then((results) => {
     console.log(results); // [1, 2, 3]
   });
   ```

6. **`Promise.race()`**：
   - 接受一个 `Promise` 数组，返回第一个完成的 `Promise` 的结果。
   ```javascript
   const p1 = new Promise((resolve) => setTimeout(resolve, 1000, "One"));
   const p2 = new Promise((resolve) => setTimeout(resolve, 500, "Two"));
   
   Promise.race([p1, p2]).then((result) => {
     console.log(result); // "Two"
   });
   ```

---

## 11.3 async/await

1. **定义**：
   - `async/await` 是 ES8 引入的语法糖，用于更简洁地处理异步操作。
   - `async` 函数返回一个 `Promise`。
   - `await` 用于等待一个 `Promise` 的结果。

2. **基本用法**：
   ```javascript
   async function fetchData() {
     const response = await fetch("https://api.example.com/data");
     const data = await response.json();
     console.log(data);
   }
   
   fetchData();
   ```

3. **错误处理**：
   - 使用 `try...catch` 捕获错误。
   ```javascript
   async function fetchData() {
     try {
       const response = await fetch("https://api.example.com/data");
       const data = await response.json();
       console.log(data);
     } catch (error) {
       console.error("Error:", error);
     }
   }
   
   fetchData();
   ```

4. **并行执行**：
   - 使用 `Promise.all()` 实现并行执行。
   ```javascript
   async function fetchMultipleData() {
     const [data1, data2] = await Promise.all([
       fetch("https://api.example.com/data1").then((res) => res.json()),
       fetch("https://api.example.com/data2").then((res) => res.json()),
     ]);
     console.log(data1, data2);
   }
   
   fetchMultipleData();
   ```

---

## 11.4 事件循环与微任务

1. **事件循环**：
   - JavaScript 是单线程的，通过事件循环处理异步任务。
   - 任务分为两类：
     - **宏任务**（Macro Task）：如 `setTimeout`、`setInterval`、`I/O`。
     - **微任务**（Micro Task）：如 `Promise.then`、`MutationObserver`。

2. **执行顺序**：
   - 微任务优先于宏任务执行。
   ```javascript
   console.log("Start");
   
   setTimeout(() => {
     console.log("Macro Task");
   }, 0);
   
   Promise.resolve().then(() => {
     console.log("Micro Task");
   });
   
   console.log("End");
   ```

   **输出顺序**：
   ```
   Start
   End
   Micro Task
   Macro Task
   ```

---

# 第十一章：经典面试题及解析

## 1. 什么是 Promise？它有哪些状态？

### 答案：
- **Promise** 是一种异步编程解决方案，用于更优雅地处理异步操作。
- **状态**：
  1. `pending`（进行中）。
  2. `fulfilled`（已成功）。
  3. `rejected`（已失败）。

---

## 2. 以下代码的输出是什么？

```javascript
const promise = new Promise((resolve, reject) => {
  console.log("Promise started");
  resolve("Success");
});

promise.then((result) => {
  console.log(result);
});

console.log("End");
```

### 答案：
输出：
```
Promise started
End
Success
```

### 解析：
- `Promise` 构造函数中的代码是同步执行的。
- `then` 中的回调是异步执行的，放入微任务队列。

---

## 3. 如何使用 `Promise.all()` 和 `Promise.race()`？

### 答案：
- **`Promise.all()`**：等待所有 `Promise` 完成，返回结果数组。
- **`Promise.race()`**：返回第一个完成的 `Promise` 的结果。

### 示例：
```javascript
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

Promise.all([p1, p2, p3]).then((results) => {
  console.log(results); // [1, 2, 3]
});

Promise.race([p1, p2, p3]).then((result) => {
  console.log(result); // 1
});
```

---

## 4. 以下代码的输出是什么？

```javascript
async function test() {
  console.log("Start");
  await Promise.resolve();
  console.log("End");
}

test();
console.log("Outside");
```

### 答案：
输出：
```
Start
Outside
End
```

### 解析：
- `async` 函数中的代码在 `await` 之前是同步执行的。
- `await` 后的代码会被放入微任务队列。

---

## 5. 如何使用 `async/await` 捕获错误？

### 答案：
使用 `try...catch` 捕获错误。

### 示例：
```javascript
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Error:", error);
  }
}

fetchData();
```

---

## 6. 以下代码的输出是什么？

```javascript
console.log("Start");

setTimeout(() => {
  console.log("Macro Task");
}, 0);

Promise.resolve().then(() => {
  console.log("Micro Task");
});

console.log("End");
```

### 答案：
输出：
```
Start
End
Micro Task
Macro Task
```

### 解析：
- 同步代码先执行。
- 微任务（`Promise.then`）优先于宏任务（`setTimeout`）。

---

以上是《JavaScript高级程序设计》第11章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第12章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第12章：BOM（浏览器对象模型）

## 12.1 BOM 的概述

1. **定义**：
   - BOM（Browser Object Model，浏览器对象模型）提供与浏览器交互的 API。
   - BOM 的核心是 `window` 对象，`window` 是全局对象，所有全局变量和函数都是 `window` 的属性或方法。

2. **BOM 的组成**：
   - `window`：全局作用域对象。
   - `navigator`：提供浏览器信息。
   - `location`：提供当前 URL 信息。
   - `history`：管理浏览器的历史记录。
   - `screen`：提供屏幕信息。
   - `document`：提供对 DOM 的访问（DOM 是 BOM 的一部分）。

---

## 12.2 window 对象

1. **全局作用域**：
   - 在浏览器中，`window` 是全局对象。
   - 示例：
     ```javascript
     var a = 10;
     console.log(window.a); // 10
     ```

2. **常用方法**：
   - **弹出框**：
     - `alert(message)`：显示警告框。
     - `confirm(message)`：显示确认框，返回布尔值。
     - `prompt(message, defaultValue)`：显示输入框，返回用户输入的值。
   - **定时器**：
     - `setTimeout(callback, delay)`：延迟执行代码。
     - `setInterval(callback, delay)`：周期性执行代码。
     - `clearTimeout(id)`：清除延迟任务。
     - `clearInterval(id)`：清除周期任务。
   - **打开和关闭窗口**：
     - `open(url, name, specs)`：打开新窗口。
     - `close()`：关闭当前窗口。

3. **窗口大小**：
   - `window.innerWidth` 和 `window.innerHeight`：窗口的内部宽高（包括滚动条）。
   - `document.documentElement.clientWidth` 和 `document.documentElement.clientHeight`：视口的宽高。

---

## 12.3 location 对象

1. **定义**：
   - `location` 对象提供当前 URL 的信息，并允许导航到新页面。

2. **常用属性**：
   - `location.href`：完整的 URL。
   - `location.protocol`：协议（如 `http:`）。
   - `location.host`：主机名和端口号。
   - `location.hostname`：主机名。
   - `location.port`：端口号。
   - `location.pathname`：路径。
   - `location.search`：查询字符串。
   - `location.hash`：锚点。

3. **常用方法**：
   - `location.assign(url)`：加载新页面。
   - `location.replace(url)`：加载新页面（不会保存到历史记录）。
   - `location.reload()`：重新加载当前页面。

4. **示例**：
   ```javascript
   console.log(location.href); // 当前页面的完整 URL
   location.assign("https://example.com"); // 跳转到新页面
   ```

---

## 12.4 navigator 对象

1. **定义**：
   - `navigator` 对象提供浏览器和操作系统的信息。

2. **常用属性**：
   - `navigator.userAgent`：用户代理字符串。
   - `navigator.platform`：操作系统平台。
   - `navigator.language`：浏览器的语言设置。
   - `navigator.onLine`：是否处于在线状态。

3. **示例**：
   ```javascript
   console.log(navigator.userAgent); // 浏览器的用户代理字符串
   console.log(navigator.language); // 浏览器的语言
   console.log(navigator.onLine); // true 或 false
   ```

---

## 12.5 screen 对象

1. **定义**：
   - `screen` 对象提供用户屏幕的信息。

2. **常用属性**：
   - `screen.width` 和 `screen.height`：屏幕的宽高。
   - `screen.availWidth` 和 `screen.availHeight`：屏幕的可用宽高（不包括任务栏等）。
   - `screen.colorDepth`：屏幕的颜色深度。

3. **示例**：
   ```javascript
   console.log(screen.width); // 屏幕宽度
   console.log(screen.height); // 屏幕高度
   console.log(screen.colorDepth); // 屏幕颜色深度
   ```

---

## 12.6 history 对象

1. **定义**：
   - `history` 对象用于操作浏览器的历史记录。

2. **常用方法**：
   - `history.back()`：返回上一页。
   - `history.forward()`：前进到下一页。
   - `history.go(n)`：跳转到历史记录中的某一页，`n` 为相对位置。

3. **示例**：
   ```javascript
   history.back(); // 返回上一页
   history.forward(); // 前进到下一页
   history.go(-1); // 返回上一页
   history.go(1); // 前进到下一页
   ```

---

# 第十二章：经典面试题及解析

## 1. 什么是 BOM？它的核心对象是什么？

### 答案：
- **BOM**（浏览器对象模型）提供与浏览器交互的 API。
- **核心对象**是 `window`，它是全局对象，所有全局变量和函数都是 `window` 的属性或方法。

---

## 2. 以下代码的输出是什么？

```javascript
var a = 10;
console.log(window.a);
```

### 答案：
输出：
```
10
```

### 解析：
- 在浏览器中，`window` 是全局对象，`var` 声明的全局变量会成为 `window` 的属性。

---

## 3. 如何使用 `location` 对象跳转到新页面？

### 答案：
可以使用 `location.assign()` 或直接设置 `location.href`。

### 示例：
```javascript
location.assign("https://example.com"); // 跳转到新页面
location.href = "https://example.com"; // 跳转到新页面
```

---

## 4. 以下代码的输出是什么？

```javascript
console.log(location.href);
console.log(location.protocol);
console.log(location.hostname);
```

### 答案：
输出：
```
当前页面的完整 URL
当前页面的协议（如 http: 或 https:）
当前页面的主机名（如 example.com）
```

---

## 5. 如何检测用户是否在线？

### 答案：
使用 `navigator.onLine` 属性。

### 示例：
```javascript
if (navigator.onLine) {
  console.log("用户在线");
} else {
  console.log("用户离线");
}
```

---

## 6. 以下代码的输出是什么？

```javascript
console.log(screen.width);
console.log(screen.height);
console.log(screen.colorDepth);
```

### 答案：
输出：
```
屏幕的宽度（以像素为单位）
屏幕的高度（以像素为单位）
屏幕的颜色深度（如 24 表示 24 位颜色）
```

---

## 7. 如何使用 `history` 对象返回上一页？

### 答案：
使用 `history.back()` 方法。

### 示例：
```javascript
history.back(); // 返回上一页
```

---

## 8. 以下代码的输出是什么？

```javascript
setTimeout(() => {
  console.log("Hello");
}, 1000);

console.log("World");
```

### 答案：
输出：
```
World
Hello
```

### 解析：
- `setTimeout` 是异步操作，回调函数会在 1 秒后执行。
- 同步代码 `console.log("World")` 会先执行。

---

以上是《JavaScript高级程序设计》第12章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第13章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第13章：客户端检测

## 13.1 客户端检测的概述

1. **定义**：
   - 客户端检测是指通过代码检测用户的浏览器、操作系统、设备等信息，以便根据环境调整功能或提供兼容性支持。

2. **常见的客户端检测方式**：
   - **能力检测**：检测浏览器是否支持某些特性。
   - **用户代理检测**：通过 `navigator.userAgent` 检测浏览器和设备信息。
   - **平台检测**：检测操作系统和设备类型。

---

## 13.2 能力检测

1. **定义**：
   - 能力检测是通过代码检测浏览器是否支持某些功能，而不是直接检测浏览器类型。

2. **示例**：
   ```javascript
   if (typeof document.querySelector === "function") {
     console.log("支持 querySelector");
   } else {
     console.log("不支持 querySelector");
   }
   ```

3. **优点**：
   - 更加可靠，因为即使是同一浏览器的不同版本，支持的功能也可能不同。
   - 避免硬编码浏览器名称。

---

## 13.3 用户代理检测

1. **定义**：
   - 用户代理字符串（`navigator.userAgent`）包含浏览器、操作系统和设备的信息。

2. **示例**：
   ```javascript
   console.log(navigator.userAgent);
   ```

3. **常见的用户代理字符串片段**：
   - Chrome：`Chrome/xx.x.xxxx.xx`
   - Firefox：`Firefox/xx.x`
   - Safari：`Safari/xx.x.xxxx`
   - Edge：`Edg/xx.x.xxxx.xx`

4. **检测浏览器类型**：
   ```javascript
   const userAgent = navigator.userAgent;
   
   if (userAgent.includes("Chrome")) {
     console.log("这是 Chrome 浏览器");
   } else if (userAgent.includes("Firefox")) {
     console.log("这是 Firefox 浏览器");
   } else if (userAgent.includes("Safari")) {
     console.log("这是 Safari 浏览器");
   }
   ```

5. **缺点**：
   - 用户代理字符串可以被伪造。
   - 不同版本的浏览器可能有不同的用户代理格式。

---

## 13.4 平台检测

1. **定义**：
   - 平台检测是通过 `navigator.platform` 检测用户的操作系统和设备类型。

2. **示例**：
   ```javascript
   console.log(navigator.platform);
   ```

3. **常见的 `navigator.platform` 值**：
   - Windows：`Win32` 或 `Win64`
   - macOS：`MacIntel`
   - Linux：`Linux x86_64`
   - iOS：`iPhone` 或 `iPad`
   - Android：`Linux armv7l`

4. **检测操作系统**：
   ```javascript
   const platform = navigator.platform;
   
   if (platform.includes("Win")) {
     console.log("这是 Windows 系统");
   } else if (platform.includes("Mac")) {
     console.log("这是 macOS 系统");
   } else if (platform.includes("Linux")) {
     console.log("这是 Linux 系统");
   }
   ```

---

## 13.5 设备检测

1. **定义**：
   - 设备检测是通过用户代理字符串或屏幕尺寸检测用户的设备类型（如手机、平板、桌面设备）。

2. **示例**：
   ```javascript
   const isMobile = /Mobile|Android|iP(hone|ad)/.test(navigator.userAgent);
   if (isMobile) {
     console.log("这是移动设备");
   } else {
     console.log("这是桌面设备");
   }
   ```

3. **通过屏幕尺寸检测**：
   ```javascript
   if (screen.width <= 768) {
     console.log("这是移动设备");
   } else {
     console.log("这是桌面设备");
   }
   ```

---

## 13.6 客户端检测的最佳实践

1. **优先使用能力检测**：
   - 能力检测更可靠，避免硬编码浏览器名称。

2. **避免过度依赖用户代理检测**：
   - 用户代理字符串可能被伪造。

3. **结合多种检测方式**：
   - 根据实际需求，结合能力检测、用户代理检测和平台检测。

---

# 第十三章：经典面试题及解析

## 1. 什么是能力检测？它与用户代理检测的区别是什么？

### 答案：
- **能力检测**是通过代码检测浏览器是否支持某些功能。
- **用户代理检测**是通过 `navigator.userAgent` 检测浏览器和设备信息。

### 区别：
- **能力检测**更可靠，因为它直接检测功能支持情况。
- **用户代理检测**可能不准确，因为用户代理字符串可以被伪造。

---

## 2. 以下代码的输出是什么？

```javascript
if (typeof document.querySelector === "function") {
  console.log("支持 querySelector");
} else {
  console.log("不支持 querySelector");
}
```

### 答案：
输出：
```
支持 querySelector
```

### 解析：
- 现代浏览器都支持 `querySelector` 方法，因此输出 "支持 querySelector"。

---

## 3. 如何检测用户的浏览器类型？

### 答案：
通过 `navigator.userAgent` 检测用户代理字符串。

### 示例：
```javascript
const userAgent = navigator.userAgent;

if (userAgent.includes("Chrome")) {
  console.log("这是 Chrome 浏览器");
} else if (userAgent.includes("Firefox")) {
  console.log("这是 Firefox 浏览器");
} else if (userAgent.includes("Safari")) {
  console.log("这是 Safari 浏览器");
}
```

---

## 4. 以下代码的输出是什么？

```javascript
console.log(navigator.platform);
```

### 答案：
输出：
```
当前设备的操作系统平台（如 "Win32"、"MacIntel"、"Linux x86_64" 等）
```

---

## 5. 如何检测用户是否使用移动设备？

### 答案：
通过用户代理字符串或屏幕尺寸检测。

### 示例 1：用户代理字符串检测
```javascript
const isMobile = /Mobile|Android|iP(hone|ad)/.test(navigator.userAgent);
if (isMobile) {
  console.log("这是移动设备");
} else {
  console.log("这是桌面设备");
}
```

### 示例 2：屏幕尺寸检测
```javascript
if (screen.width <= 768) {
  console.log("这是移动设备");
} else {
  console.log("这是桌面设备");
}
```

---

## 6. 以下代码的输出是什么？

```javascript
const platform = navigator.platform;

if (platform.includes("Win")) {
  console.log("这是 Windows 系统");
} else if (platform.includes("Mac")) {
  console.log("这是 macOS 系统");
} else if (platform.includes("Linux")) {
  console.log("这是 Linux 系统");
}
```

### 答案：
输出：
```
根据用户的操作系统平台，输出 "这是 Windows 系统"、"这是 macOS 系统" 或 "这是 Linux 系统"。
```

---

## 7. 为什么优先使用能力检测而不是用户代理检测？

### 答案：
- **能力检测**直接检测功能支持情况，更加可靠。
- **用户代理检测**依赖用户代理字符串，可能被伪造或格式不一致。

---

以上是《JavaScript高级程序设计》第13章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第14章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第14章：DOM（文档对象模型）

## 14.1 DOM 的概述

1. **定义**：
   - DOM（Document Object Model，文档对象模型）是 HTML 和 XML 文档的编程接口。
   - DOM 将文档表示为树形结构，开发者可以通过 JavaScript 操作文档的内容和结构。

2. **DOM 的组成**：
   - **节点**：文档中的每个部分（元素、属性、文本等）都是一个节点。
   - **节点类型**：
     - 元素节点（`Element`）：表示 HTML 或 XML 元素。
     - 属性节点（`Attr`）：表示元素的属性。
     - 文本节点（`Text`）：表示元素或属性中的文本内容。
     - 文档节点（`Document`）：表示整个文档。
     - 注释节点（`Comment`）：表示注释。

---

## 14.2 DOM 节点

1. **节点属性**：
   - `nodeType`：节点类型（1 表示元素节点，3 表示文本节点）。
   - `nodeName`：节点的名称。
   - `nodeValue`：节点的值（仅适用于文本节点和注释节点）。

2. **节点关系**：
   - `parentNode`：父节点。
   - `childNodes`：子节点的集合。
   - `firstChild` 和 `lastChild`：第一个和最后一个子节点。
   - `previousSibling` 和 `nextSibling`：前一个和后一个兄弟节点。

3. **示例**：
   ```javascript
   const element = document.getElementById("example");
   console.log(element.nodeType); // 1
   console.log(element.nodeName); // "DIV"
   console.log(element.parentNode); // 父节点
   console.log(element.childNodes); // 子节点集合
   ```

---

## 14.3 操作 DOM 节点

1. **创建节点**：
   - `document.createElement(tagName)`：创建元素节点。
   - `document.createTextNode(text)`：创建文本节点。

2. **添加节点**：
   - `appendChild(node)`：将节点添加为子节点。
   - `insertBefore(newNode, referenceNode)`：在指定节点前插入新节点。

3. **删除节点**：
   - `removeChild(node)`：删除子节点。

4. **替换节点**：
   - `replaceChild(newNode, oldNode)`：用新节点替换旧节点。

5. **示例**：
   ```javascript
   const parent = document.getElementById("parent");
   const newElement = document.createElement("div");
   newElement.textContent = "Hello, DOM!";
   parent.appendChild(newElement); // 添加新节点
   ```

---

## 14.4 操作元素属性

1. **获取和设置属性**：
   - `getAttribute(name)`：获取属性值。
   - `setAttribute(name, value)`：设置属性值。
   - `removeAttribute(name)`：移除属性。

2. **直接操作属性**：
   - 使用点操作符直接访问属性。
   - 示例：
     ```javascript
     const element = document.getElementById("example");
     element.id = "newId"; // 设置 id 属性
     console.log(element.id); // 获取 id 属性
     ```

3. **示例**：
   ```javascript
   const element = document.getElementById("example");
   element.setAttribute("class", "highlight"); // 设置 class 属性
   console.log(element.getAttribute("class")); // 获取 class 属性
   element.removeAttribute("class"); // 移除 class 属性
   ```

---

## 14.5 操作样式

1. **直接设置样式**：
   - 使用 `style` 属性设置内联样式。
   - 示例：
     ```javascript
     const element = document.getElementById("example");
     element.style.color = "red";
     element.style.fontSize = "20px";
     ```

2. **获取计算样式**：
   - 使用 `getComputedStyle(element)` 获取元素的计算样式。
   - 示例：
     ```javascript
     const element = document.getElementById("example");
     const styles = getComputedStyle(element);
     console.log(styles.color); // 获取计算后的颜色
     ```

---

## 14.6 查询 DOM

1. **常用方法**：
   - `getElementById(id)`：通过 ID 获取元素。
   - `getElementsByTagName(tagName)`：通过标签名获取元素集合。
   - `getElementsByClassName(className)`：通过类名获取元素集合。
   - `querySelector(selector)`：通过 CSS 选择器获取第一个匹配的元素。
   - `querySelectorAll(selector)`：通过 CSS 选择器获取所有匹配的元素。

2. **示例**：
   ```javascript
   const element = document.getElementById("example");
   const elements = document.getElementsByClassName("highlight");
   const firstElement = document.querySelector(".highlight");
   const allElements = document.querySelectorAll(".highlight");
   ```

---

## 14.7 事件处理

1. **添加事件监听器**：
   - 使用 `addEventListener(type, listener)` 添加事件监听器。
   - 示例：
     ```javascript
     const button = document.getElementById("button");
     button.addEventListener("click", () => {
       console.log("Button clicked!");
     });
     ```

2. **移除事件监听器**：
   - 使用 `removeEventListener(type, listener)` 移除事件监听器。

3. **事件对象**：
   - `event.target`：触发事件的元素。
   - `event.type`：事件的类型。
   - `event.preventDefault()`：阻止默认行为。
   - `event.stopPropagation()`：阻止事件冒泡。

---

# 第十四章：经典面试题及解析

## 1. 什么是 DOM？DOM 的节点类型有哪些？

### 答案：
- **DOM**（文档对象模型）是 HTML 和 XML 文档的编程接口，将文档表示为树形结构。
- **节点类型**：
  1. 元素节点（`Element`）。
  2. 属性节点（`Attr`）。
  3. 文本节点（`Text`）。
  4. 文档节点（`Document`）。
  5. 注释节点（`Comment`）。

---

## 2. 以下代码的输出是什么？

```javascript
const element = document.getElementById("example");
console.log(element.nodeType);
console.log(element.nodeName);
```

### 答案：
输出：
```
1
"DIV"
```

### 解析：
- `nodeType` 为 1 表示元素节点。
- `nodeName` 返回节点的名称（大写）。

---

## 3. 如何创建并添加一个新节点？

### 答案：
使用 `document.createElement()` 创建节点，使用 `appendChild()` 添加节点。

### 示例：
```javascript
const parent = document.getElementById("parent");
const newElement = document.createElement("div");
newElement.textContent = "Hello, DOM!";
parent.appendChild(newElement);
```

---

## 4. 以下代码的输出是什么？

```javascript
const element = document.getElementById("example");
element.setAttribute("class", "highlight");
console.log(element.getAttribute("class"));
element.removeAttribute("class");
console.log(element.getAttribute("class"));
```

### 答案：
输出：
```
"highlight"
null
```

### 解析：
- `setAttribute()` 设置属性。
- `removeAttribute()` 移除属性。

---

## 5. 如何获取元素的计算样式？

### 答案：
使用 `getComputedStyle(element)` 获取计算样式。

### 示例：
```javascript
const element = document.getElementById("example");
const styles = getComputedStyle(element);
console.log(styles.color); // 获取计算后的颜色
```

---

## 6. 以下代码的输出是什么？

```javascript
const button = document.getElementById("button");
button.addEventListener("click", () => {
  console.log("Button clicked!");
});
button.click();
```

### 答案：
输出：
```
Button clicked!
```

### 解析：
- `addEventListener()` 添加事件监听器。
- `button.click()` 模拟点击事件。

---

## 7. 如何通过类名获取所有匹配的元素？

### 答案：
使用 `getElementsByClassName()` 或 `querySelectorAll()`。

### 示例：
```javascript
const elements = document.getElementsByClassName("highlight");
const allElements = document.querySelectorAll(".highlight");
```

---

以上是《JavaScript高级程序设计》第14章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第14章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第14章：DOM（文档对象模型）

## 14.1 DOM 的概述

1. **定义**：
   - DOM（Document Object Model，文档对象模型）是 HTML 和 XML 文档的编程接口。
   - DOM 将文档表示为树形结构，开发者可以通过 JavaScript 操作文档的内容和结构。

2. **DOM 的组成**：
   - **节点**：文档中的每个部分（元素、属性、文本等）都是一个节点。
   - **节点类型**：
     - 元素节点（`Element`）：表示 HTML 或 XML 元素。
     - 属性节点（`Attr`）：表示元素的属性。
     - 文本节点（`Text`）：表示元素或属性中的文本内容。
     - 文档节点（`Document`）：表示整个文档。
     - 注释节点（`Comment`）：表示注释。

---

## 14.2 DOM 节点

1. **节点属性**：
   - `nodeType`：节点类型（1 表示元素节点，3 表示文本节点）。
   - `nodeName`：节点的名称。
   - `nodeValue`：节点的值（仅适用于文本节点和注释节点）。

2. **节点关系**：
   - `parentNode`：父节点。
   - `childNodes`：子节点的集合。
   - `firstChild` 和 `lastChild`：第一个和最后一个子节点。
   - `previousSibling` 和 `nextSibling`：前一个和后一个兄弟节点。

3. **示例**：
   ```javascript
   const element = document.getElementById("example");
   console.log(element.nodeType); // 1
   console.log(element.nodeName); // "DIV"
   console.log(element.parentNode); // 父节点
   console.log(element.childNodes); // 子节点集合
   ```

---

## 14.3 操作 DOM 节点

1. **创建节点**：
   - `document.createElement(tagName)`：创建元素节点。
   - `document.createTextNode(text)`：创建文本节点。

2. **添加节点**：
   - `appendChild(node)`：将节点添加为子节点。
   - `insertBefore(newNode, referenceNode)`：在指定节点前插入新节点。

3. **删除节点**：
   - `removeChild(node)`：删除子节点。

4. **替换节点**：
   - `replaceChild(newNode, oldNode)`：用新节点替换旧节点。

5. **示例**：
   ```javascript
   const parent = document.getElementById("parent");
   const newElement = document.createElement("div");
   newElement.textContent = "Hello, DOM!";
   parent.appendChild(newElement); // 添加新节点
   ```

---

## 14.4 操作元素属性

1. **获取和设置属性**：
   - `getAttribute(name)`：获取属性值。
   - `setAttribute(name, value)`：设置属性值。
   - `removeAttribute(name)`：移除属性。

2. **直接操作属性**：
   - 使用点操作符直接访问属性。
   - 示例：
     ```javascript
     const element = document.getElementById("example");
     element.id = "newId"; // 设置 id 属性
     console.log(element.id); // 获取 id 属性
     ```

3. **示例**：
   ```javascript
   const element = document.getElementById("example");
   element.setAttribute("class", "highlight"); // 设置 class 属性
   console.log(element.getAttribute("class")); // 获取 class 属性
   element.removeAttribute("class"); // 移除 class 属性
   ```

---

## 14.5 操作样式

1. **直接设置样式**：
   - 使用 `style` 属性设置内联样式。
   - 示例：
     ```javascript
     const element = document.getElementById("example");
     element.style.color = "red";
     element.style.fontSize = "20px";
     ```

2. **获取计算样式**：
   - 使用 `getComputedStyle(element)` 获取元素的计算样式。
   - 示例：
     ```javascript
     const element = document.getElementById("example");
     const styles = getComputedStyle(element);
     console.log(styles.color); // 获取计算后的颜色
     ```

---

## 14.6 查询 DOM

1. **常用方法**：
   - `getElementById(id)`：通过 ID 获取元素。
   - `getElementsByTagName(tagName)`：通过标签名获取元素集合。
   - `getElementsByClassName(className)`：通过类名获取元素集合。
   - `querySelector(selector)`：通过 CSS 选择器获取第一个匹配的元素。
   - `querySelectorAll(selector)`：通过 CSS 选择器获取所有匹配的元素。

2. **示例**：
   ```javascript
   const element = document.getElementById("example");
   const elements = document.getElementsByClassName("highlight");
   const firstElement = document.querySelector(".highlight");
   const allElements = document.querySelectorAll(".highlight");
   ```

---

## 14.7 事件处理

1. **添加事件监听器**：
   - 使用 `addEventListener(type, listener)` 添加事件监听器。
   - 示例：
     ```javascript
     const button = document.getElementById("button");
     button.addEventListener("click", () => {
       console.log("Button clicked!");
     });
     ```

2. **移除事件监听器**：
   - 使用 `removeEventListener(type, listener)` 移除事件监听器。

3. **事件对象**：
   - `event.target`：触发事件的元素。
   - `event.type`：事件的类型。
   - `event.preventDefault()`：阻止默认行为。
   - `event.stopPropagation()`：阻止事件冒泡。

---

# 第十四章：经典面试题及解析

## 1. 什么是 DOM？DOM 的节点类型有哪些？

### 答案：
- **DOM**（文档对象模型）是 HTML 和 XML 文档的编程接口，将文档表示为树形结构。
- **节点类型**：
  1. 元素节点（`Element`）。
  2. 属性节点（`Attr`）。
  3. 文本节点（`Text`）。
  4. 文档节点（`Document`）。
  5. 注释节点（`Comment`）。

---

## 2. 以下代码的输出是什么？

```javascript
const element = document.getElementById("example");
console.log(element.nodeType);
console.log(element.nodeName);
```

### 答案：
输出：
```
1
"DIV"
```

### 解析：
- `nodeType` 为 1 表示元素节点。
- `nodeName` 返回节点的名称（大写）。

---

## 3. 如何创建并添加一个新节点？

### 答案：
使用 `document.createElement()` 创建节点，使用 `appendChild()` 添加节点。

### 示例：
```javascript
const parent = document.getElementById("parent");
const newElement = document.createElement("div");
newElement.textContent = "Hello, DOM!";
parent.appendChild(newElement);
```

---

## 4. 以下代码的输出是什么？

```javascript
const element = document.getElementById("example");
element.setAttribute("class", "highlight");
console.log(element.getAttribute("class"));
element.removeAttribute("class");
console.log(element.getAttribute("class"));
```

### 答案：
输出：
```
"highlight"
null
```

### 解析：
- `setAttribute()` 设置属性。
- `removeAttribute()` 移除属性。

---

## 5. 如何获取元素的计算样式？

### 答案：
使用 `getComputedStyle(element)` 获取计算样式。

### 示例：
```javascript
const element = document.getElementById("example");
const styles = getComputedStyle(element);
console.log(styles.color); // 获取计算后的颜色
```

---

## 6. 以下代码的输出是什么？

```javascript
const button = document.getElementById("button");
button.addEventListener("click", () => {
  console.log("Button clicked!");
});
button.click();
```

### 答案：
输出：
```
Button clicked!
```

### 解析：
- `addEventListener()` 添加事件监听器。
- `button.click()` 模拟点击事件。

---

## 7. 如何通过类名获取所有匹配的元素？

### 答案：
使用 `getElementsByClassName()` 或 `querySelectorAll()`。

### 示例：
```javascript
const elements = document.getElementsByClassName("highlight");
const allElements = document.querySelectorAll(".highlight");
```

---

以上是《JavaScript高级程序设计》第14章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第16章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第16章：事件

## 16.1 事件流

1. **定义**：
   - 事件流描述了事件在页面中传播的顺序。
   - 包括三个阶段：
     1. **捕获阶段**：事件从文档根节点向目标元素传播。
     2. **目标阶段**：事件到达目标元素。
     3. **冒泡阶段**：事件从目标元素向文档根节点传播。

2. **事件流模型**：
   - **IE 的事件流**：只支持冒泡阶段。
   - **DOM 的事件流**：支持捕获和冒泡阶段。

3. **示例**：
   ```javascript
   const parent = document.getElementById("parent");
   const child = document.getElementById("child");
   
   parent.addEventListener(
     "click",
     () => {
       console.log("Parent clicked (capture)");
     },
     true // 捕获阶段
   );
   
   child.addEventListener("click", () => {
     console.log("Child clicked");
   });
   
   parent.addEventListener("click", () => {
     console.log("Parent clicked (bubble)");
   });
   ```

   **输出顺序**：
   ```
   Parent clicked (capture)
   Child clicked
   Parent clicked (bubble)
   ```

---

## 16.2 事件处理程序

1. **HTML 事件处理程序**：
   - 在 HTML 中直接绑定事件。
   - 示例：
     ```html
     <button onclick="alert('Button clicked!')">Click me</button>
     ```

2. **DOM0 级事件处理程序**：
   - 使用元素的属性绑定事件。
   - 示例：
     ```javascript
     const button = document.getElementById("button");
     button.onclick = function () {
       console.log("Button clicked!");
     };
     ```

3. **DOM2 级事件处理程序**：
   - 使用 `addEventListener` 添加事件监听器。
   - 示例：
     ```javascript
     const button = document.getElementById("button");
     button.addEventListener("click", () => {
       console.log("Button clicked!");
     });
   
   ```
   
4. **移除事件监听器**：
   - 使用 `removeEventListener` 移除事件监听器。
   - 示例：
     ```javascript
     const handler = () => console.log("Button clicked!");
     button.addEventListener("click", handler);
     button.removeEventListener("click", handler);
     ```

---

## 16.3 事件对象

1. **定义**：
   - 事件对象包含与事件相关的所有信息。

2. **常用属性**：
   - `type`：事件的类型。
   - `target`：事件的目标元素。
   - `currentTarget`：事件处理程序绑定的元素。
   - `preventDefault()`：阻止默认行为。
   - `stopPropagation()`：阻止事件传播。

3. **示例**：
   ```javascript
   const link = document.getElementById("link");
   link.addEventListener("click", (event) => {
     event.preventDefault(); // 阻止默认行为
     console.log(event.type); // "click"
     console.log(event.target); // 触发事件的元素
   });
   ```

---

## 16.4 事件委托

1. **定义**：
   - 事件委托是将事件监听器绑定到父元素，通过事件冒泡处理子元素的事件。

2. **优点**：
   - 减少内存占用。
   - 动态绑定子元素的事件。

3. **示例**：
   ```javascript
   const parent = document.getElementById("parent");
   parent.addEventListener("click", (event) => {
     if (event.target.tagName === "BUTTON") {
       console.log(`Button ${event.target.textContent} clicked`);
     }
   });
   ```

---

## 16.5 自定义事件

1. **定义**：
   - 自定义事件允许开发者创建和触发自己的事件。

2. **创建和触发事件**：
   - 使用 `CustomEvent` 构造函数创建事件。
   - 使用 `dispatchEvent` 触发事件。

3. **示例**：
   ```javascript
   const button = document.getElementById("button");
   
   const customEvent = new CustomEvent("myEvent", {
     detail: { message: "Hello, Custom Event!" },
   });
   
   button.addEventListener("myEvent", (event) => {
     console.log(event.detail.message); // "Hello, Custom Event!"
   });
   
   button.dispatchEvent(customEvent); // 触发自定义事件
   ```

---

## 16.6 事件类型

1. **鼠标事件**：
   - 常见事件：`click`、`dblclick`、`mousedown`、`mouseup`、`mousemove`、`mouseenter`、`mouseleave`。
   - 示例：
     ```javascript
     const button = document.getElementById("button");
     button.addEventListener("click", () => {
       console.log("Button clicked!");
     });
     ```

2. **键盘事件**：
   - 常见事件：`keydown`、`keypress`、`keyup`。
   - 示例：
     ```javascript
     document.addEventListener("keydown", (event) => {
       console.log(`Key pressed: ${event.key}`);
     });
     ```

3. **表单事件**：
   - 常见事件：`submit`、`change`、`input`、`focus`、`blur`。
   - 示例：
     ```javascript
     const form = document.getElementById("form");
     form.addEventListener("submit", (event) => {
       event.preventDefault();
       console.log("Form submitted!");
     });
     ```

4. **其他事件**：
   - `load`、`unload`、`resize`、`scroll` 等。

---

# 第十六章：经典面试题及解析

## 1. 什么是事件流？事件流的三个阶段是什么？

### 答案：
- **事件流**描述了事件在页面中传播的顺序。
- **三个阶段**：
  1. 捕获阶段：事件从文档根节点向目标元素传播。
  2. 目标阶段：事件到达目标元素。
  3. 冒泡阶段：事件从目标元素向文档根节点传播。

---

## 2. 以下代码的输出是什么？

```javascript
const parent = document.getElementById("parent");
const child = document.getElementById("child");

parent.addEventListener(
  "click",
  () => {
    console.log("Parent clicked (capture)");
  },
  true
);

child.addEventListener("click", () => {
  console.log("Child clicked");
});

parent.addEventListener("click", () => {
  console.log("Parent clicked (bubble)");
});
```

### 答案：
输出：
```
Parent clicked (capture)
Child clicked
Parent clicked (bubble)
```

### 解析：
- 捕获阶段的事件处理程序先执行。
- 然后是目标阶段的事件处理程序。
- 最后是冒泡阶段的事件处理程序。

---

## 3. 如何阻止事件的默认行为？

### 答案：
使用 `event.preventDefault()`。

### 示例：
```javascript
const link = document.getElementById("link");
link.addEventListener("click", (event) => {
  event.preventDefault(); // 阻止默认行为
  console.log("Default behavior prevented");
});
```

---

## 4. 什么是事件委托？它的优点是什么？

### 答案：
- **事件委托**是将事件监听器绑定到父元素，通过事件冒泡处理子元素的事件。
- **优点**：
  1. 减少内存占用。
  2. 动态绑定子元素的事件。

### 示例：
```javascript
const parent = document.getElementById("parent");
parent.addEventListener("click", (event) => {
  if (event.target.tagName === "BUTTON") {
    console.log(`Button ${event.target.textContent} clicked`);
  }
});
```

---

## 5. 如何创建和触发自定义事件？

### 答案：
使用 `CustomEvent` 创建事件，使用 `dispatchEvent` 触发事件。

### 示例：
```javascript
const button = document.getElementById("button");

const customEvent = new CustomEvent("myEvent", {
  detail: { message: "Hello, Custom Event!" },
});

button.addEventListener("myEvent", (event) => {
  console.log(event.detail.message); // "Hello, Custom Event!"
});

button.dispatchEvent(customEvent); // 触发自定义事件
```

---

## 6. 以下代码的输出是什么？

```javascript
document.addEventListener("keydown", (event) => {
  console.log(`Key pressed: ${event.key}`);
});
```

### 答案：
- 当用户按下键盘上的任意键时，输出：
```
Key pressed: <键名>
```

---

以上是《JavaScript高级程序设计》第16章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第17章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第17章：表单脚本

## 17.1 表单与表单字段

1. **表单的基本结构**：
   - 表单通过 `<form>` 元素定义，包含各种表单字段（如文本框、复选框、单选按钮等）。
   - 示例：
     ```html
     <form id="myForm">
       <input type="text" name="username" />
       <input type="password" name="password" />
       <button type="submit">提交</button>
     </form>
     ```

2. **访问表单和字段**：
   - 使用 `document.forms` 访问表单集合。
   - 使用表单的 `elements` 属性访问字段集合。
   - 示例：
     ```javascript
     const form = document.forms["myForm"];
     const usernameField = form.elements["username"];
     console.log(usernameField.value); // 获取文本框的值
     ```

---

## 17.2 表单字段类型

1. **常见字段类型**：
   - 文本框：`<input type="text">`
   - 密码框：`<input type="password">`
   - 单选按钮：`<input type="radio">`
   - 复选框：`<input type="checkbox">`
   - 下拉列表：`<select>`
   - 文本区域：`<textarea>`
   - 文件选择框：`<input type="file">`
   - 按钮：`<button>` 或 `<input type="submit">`

2. **字段的常用属性**：
   - `value`：字段的值。
   - `checked`：复选框或单选按钮是否被选中。
   - `disabled`：字段是否被禁用。
   - `name`：字段的名称。
   - `type`：字段的类型。

3. **示例**：
   ```javascript
   const checkbox = document.querySelector('input[type="checkbox"]');
   console.log(checkbox.checked); // 检查是否选中
   checkbox.checked = true; // 设置为选中
   ```

---

## 17.3 表单序列化

1. **定义**：
   - 表单序列化是将表单字段的名称和值转换为 URL 编码的字符串。

2. **手动序列化**：
   ```javascript
   const form = document.forms["myForm"];
   const data = new URLSearchParams(new FormData(form)).toString();
   console.log(data); // "username=Alice&password=12345"
   ```

3. **使用 `FormData` 对象**：
   - `FormData` 提供了一种更方便的方式来处理表单数据。
   - 示例：
     ```javascript
     const form = document.forms["myForm"];
     const formData = new FormData(form);
     
     for (const [name, value] of formData) {
       console.log(`${name}: ${value}`);
     }
     ```

---

## 17.4 表单验证

1. **HTML5 表单验证**：
   - 使用表单字段的验证属性：
     - `required`：字段是否必填。
     - `min` 和 `max`：数值或日期的最小值和最大值。
     - `minlength` 和 `maxlength`：文本的最小长度和最大长度。
     - `pattern`：正则表达式模式。
     - `type`：字段类型（如 `email`、`url` 等）。

   - 示例：
     ```html
     <input type="email" required />
     <input type="text" pattern="\d{3}-\d{4}" />
     ```

2. **使用 JavaScript 验证**：
   - 检查字段的 `validity` 属性。
   - 示例：
     ```javascript
     const input = document.querySelector('input[type="email"]');
     if (!input.validity.valid) {
       console.log("输入无效");
     }
     ```

3. **阻止表单提交**：
   - 使用 `event.preventDefault()` 阻止默认提交行为。
   - 示例：
     ```javascript
     const form = document.getElementById("myForm");
     form.addEventListener("submit", (event) => {
       if (!form.checkValidity()) {
         event.preventDefault();
         console.log("表单验证失败");
       }
     });
     ```

---

## 17.5 富文本编辑

1. **`contenteditable` 属性**：
   - 使元素变为可编辑。
   - 示例：
     ```html
     <div contenteditable="true">这是可编辑的内容</div>
     ```

2. **操作富文本内容**：
   - 使用 `document.execCommand` 执行编辑命令。
   - 示例：
     ```javascript
     document.execCommand("bold"); // 加粗选中文本
     document.execCommand("italic"); // 斜体选中文本
     ```

3. **获取和设置内容**：
   - 使用 `innerHTML` 或 `textContent` 获取和设置内容。
   - 示例：
     ```javascript
     const editableDiv = document.querySelector('[contenteditable="true"]');
     console.log(editableDiv.innerHTML); // 获取 HTML 内容
     editableDiv.textContent = "新内容"; // 设置文本内容
     ```

---

# 第十七章：经典面试题及解析

## 1. 如何通过 JavaScript 获取表单字段的值？

### 答案：
使用表单的 `elements` 属性访问字段，然后获取字段的 `value` 属性。

### 示例：
```javascript
const form = document.forms["myForm"];
const usernameField = form.elements["username"];
console.log(usernameField.value); // 获取文本框的值
```

---

## 2. 以下代码的输出是什么？

```html
<form id="myForm">
  <input type="text" name="username" value="Alice" />
  <input type="password" name="password" value="12345" />
</form>
```

```javascript
const form = document.forms["myForm"];
const data = new URLSearchParams(new FormData(form)).toString();
console.log(data);
```

### 答案：
输出：
```
username=Alice&password=12345
```

### 解析：
- `FormData` 对象收集表单字段的名称和值。
- `URLSearchParams` 将数据序列化为 URL 编码的字符串。

---

## 3. 如何阻止表单的默认提交行为？

### 答案：
使用 `event.preventDefault()`。

### 示例：
```javascript
const form = document.getElementById("myForm");
form.addEventListener("submit", (event) => {
  event.preventDefault(); // 阻止默认提交行为
  console.log("表单提交被阻止");
});
```

---

## 4. 以下代码的输出是什么？

```html
<input type="text" id="input" pattern="\d{3}-\d{4}" required />
```

```javascript
const input = document.getElementById("input");
console.log(input.validity.valid);
```

### 答案：
- 如果输入值符合模式 `\d{3}-\d{4}` 且非空，则输出 `true`。
- 否则输出 `false`。

---

## 5. 如何使一个元素变为可编辑？

### 答案：
使用 `contenteditable` 属性。

### 示例：
```html
<div contenteditable="true">这是可编辑的内容</div>
```

---

## 6. 如何使用 JavaScript 验证表单字段？

### 答案：
使用字段的 `validity` 属性检查验证状态。

### 示例：
```javascript
const input = document.querySelector('input[type="email"]');
if (!input.validity.valid) {
  console.log("输入无效");
}
```

---

## 7. 以下代码的输出是什么？

```javascript
const editableDiv = document.querySelector('[contenteditable="true"]');
editableDiv.textContent = "新内容";
console.log(editableDiv.textContent);
```

### 答案：
输出：
```
新内容
```

### 解析：
- `textContent` 设置和获取元素的文本内容。

---

以上是《JavaScript高级程序设计》第17章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第18章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第18章：使用 Canvas 绘图

## 18.1 Canvas 概述

1. **定义**：
   - `Canvas` 是 HTML5 提供的一个用于绘制图形的元素，通过 JavaScript 操作其 2D 或 3D 绘图上下文。

2. **基本结构**：
   ```html
   <canvas id="myCanvas" width="500" height="500"></canvas>
   ```

3. **获取绘图上下文**：
   - 使用 `getContext("2d")` 获取 2D 绘图上下文。
   - 示例：
     ```javascript
     const canvas = document.getElementById("myCanvas");
     const ctx = canvas.getContext("2d");
     ```

---

## 18.2 绘制矩形

1. **方法**：
   - `fillRect(x, y, width, height)`：绘制填充的矩形。
   - `strokeRect(x, y, width, height)`：绘制矩形的边框。
   - `clearRect(x, y, width, height)`：清除矩形区域。

2. **示例**：
   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");
   
   ctx.fillStyle = "blue"; // 设置填充颜色
   ctx.fillRect(50, 50, 100, 100); // 绘制填充矩形
   
   ctx.strokeStyle = "red"; // 设置边框颜色
   ctx.strokeRect(200, 50, 100, 100); // 绘制矩形边框
   
   ctx.clearRect(60, 60, 80, 80); // 清除矩形区域
   ```

---

## 18.3 绘制路径

1. **方法**：
   - `beginPath()`：开始新路径。
   - `moveTo(x, y)`：移动到指定位置。
   - `lineTo(x, y)`：绘制直线。
   - `closePath()`：关闭路径。
   - `stroke()`：绘制路径。
   - `fill()`：填充路径。

2. **示例**：
   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");
   
   ctx.beginPath();
   ctx.moveTo(50, 50); // 起点
   ctx.lineTo(150, 50); // 绘制直线
   ctx.lineTo(100, 150); // 绘制直线
   ctx.closePath(); // 闭合路径
   
   ctx.strokeStyle = "green";
   ctx.stroke(); // 绘制路径
   
   ctx.fillStyle = "yellow";
   ctx.fill(); // 填充路径
   ```

---

## 18.4 绘制圆形和弧线

1. **方法**：
   - `arc(x, y, radius, startAngle, endAngle, anticlockwise)`：绘制弧线或圆。
   - `arcTo(x1, y1, x2, y2, radius)`：绘制两点之间的弧线。

2. **示例**：
   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");
   
   ctx.beginPath();
   ctx.arc(150, 150, 50, 0, Math.PI * 2, false); // 绘制圆
   ctx.fillStyle = "purple";
   ctx.fill(); // 填充圆
   ctx.stroke();
   ```

---

## 18.5 绘制文本

1. **方法**：
   - `fillText(text, x, y, maxWidth)`：绘制填充文本。
   - `strokeText(text, x, y, maxWidth)`：绘制文本边框。

2. **设置文本样式**：
   - `font`：设置字体样式。
   - `textAlign`：设置文本对齐方式（`left`、`center`、`right`）。
   - `textBaseline`：设置文本基线（`top`、`middle`、`bottom`）。

3. **示例**：
   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");
   
   ctx.font = "30px Arial";
   ctx.fillStyle = "black";
   ctx.textAlign = "center";
   ctx.fillText("Hello, Canvas!", 150, 150); // 绘制填充文本
   
   ctx.strokeStyle = "blue";
   ctx.strokeText("Hello, Canvas!", 150, 200); // 绘制文本边框
   ```

---

## 18.6 绘制图像

1. **方法**：
   - `drawImage(image, dx, dy)`：在指定位置绘制图像。
   - `drawImage(image, dx, dy, dWidth, dHeight)`：缩放图像。
   - `drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)`：裁剪并绘制图像。

2. **示例**：
   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");
   
   const img = new Image();
   img.src = "example.jpg";
   img.onload = () => {
     ctx.drawImage(img, 50, 50, 200, 150); // 绘制图像
   };
   ```

---

## 18.7 变换

1. **方法**：
   - `translate(x, y)`：平移。
   - `rotate(angle)`：旋转。
   - `scale(x, y)`：缩放。
   - `transform(a, b, c, d, e, f)`：应用矩阵变换。

2. **示例**：
   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");
   
   ctx.translate(100, 100); // 平移
   ctx.rotate((Math.PI / 180) * 45); // 旋转 45 度
   ctx.fillStyle = "red";
   ctx.fillRect(0, 0, 50, 50); // 绘制矩形
   ```

---

## 18.8 保存与恢复状态

1. **方法**：
   - `save()`：保存当前绘图状态。
   - `restore()`：恢复之前保存的状态。

2. **示例**：
   ```javascript
   const canvas = document.getElementById("myCanvas");
   const ctx = canvas.getContext("2d");
   
   ctx.fillStyle = "blue";
   ctx.save(); // 保存状态
   
   ctx.fillStyle = "red";
   ctx.fillRect(50, 50, 100, 100); // 绘制红色矩形
   
   ctx.restore(); // 恢复状态
   ctx.fillRect(200, 50, 100, 100); // 绘制蓝色矩形
   ```

---

# 第十八章：经典面试题及解析

## 1. 如何在 Canvas 中绘制一个填充的矩形？

### 答案：
使用 `fillRect(x, y, width, height)` 方法。

### 示例：
```javascript
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

ctx.fillStyle = "blue";
ctx.fillRect(50, 50, 100, 100);
```

---

## 2. 以下代码的输出是什么？

```javascript
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

ctx.beginPath();
ctx.moveTo(50, 50);
ctx.lineTo(150, 50);
ctx.lineTo(100, 150);
ctx.closePath();

ctx.strokeStyle = "green";
ctx.stroke();

ctx.fillStyle = "yellow";
ctx.fill();
```

### 答案：
- 输出一个绿色边框、黄色填充的三角形。

---

## 3. 如何在 Canvas 中绘制一个圆？

### 答案：
使用 `arc(x, y, radius, startAngle, endAngle, anticlockwise)` 方法。

### 示例：
```javascript
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

ctx.beginPath();
ctx.arc(150, 150, 50, 0, Math.PI * 2, false);
ctx.fillStyle = "purple";
ctx.fill();
ctx.stroke();
```

---

## 4. 如何在 Canvas 中绘制文本？

### 答案：
使用 `fillText` 或 `strokeText` 方法。

### 示例：
```javascript
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

ctx.font = "30px Arial";
ctx.fillStyle = "black";
ctx.fillText("Hello, Canvas!", 150, 150);
```

---

## 5. 如何在 Canvas 中绘制图像？

### 答案：
使用 `drawImage` 方法。

### 示例：
```javascript
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

const img = new Image();
img.src = "example.jpg";
img.onload = () => {
  ctx.drawImage(img, 50, 50, 200, 150);
};
```

---

## 6. 以下代码的输出是什么？

```javascript
const canvas = document.getElementById("myCanvas");
const ctx = canvas.getContext("2d");

ctx.fillStyle = "blue";
ctx.save();

ctx.fillStyle = "red";
ctx.fillRect(50, 50, 100, 100);

ctx.restore();
ctx.fillRect(200, 50, 100, 100);
```

### 答案：
- 输出一个红色矩形（位置：50, 50）和一个蓝色矩形（位置：200, 50）。

---

以上是《JavaScript高级程序设计》第18章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第19章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第19章：HTML5 脚本编程

## 19.1 跨文档消息传递（Cross-Document Messaging）

1. **定义**：
   - 跨文档消息传递（`postMessage`）允许不同源的窗口或 iframe 之间进行安全通信。

2. **发送消息**：
   - 使用 `postMessage` 方法发送消息。
   - 语法：
     ```javascript
     otherWindow.postMessage(message, targetOrigin);
     ```
     - `message`：要发送的数据，可以是字符串或对象。
     - `targetOrigin`：指定接收消息的目标源（如 `"https://example.com"`）。

3. **接收消息**：
   - 监听 `message` 事件接收消息。
   - 示例：
     ```javascript
     window.addEventListener("message", (event) => {
       if (event.origin === "https://example.com") {
         console.log("收到消息：", event.data);
       }
     });
     ```

4. **示例**：
   ```javascript
   // 发送消息
   const iframe = document.getElementById("myIframe");
   iframe.contentWindow.postMessage("Hello from parent", "https://example.com");
   
   // 接收消息
   window.addEventListener("message", (event) => {
     if (event.origin === "https://example.com") {
       console.log("收到消息：", event.data);
     }
   });
   ```

---

## 19.2 Web Workers

1. **定义**：
   - Web Workers 是 HTML5 提供的一种多线程机制，用于在后台运行 JavaScript 脚本，不会阻塞主线程。

2. **创建 Worker**：
   - 使用 `new Worker()` 创建 Worker。
   - 示例：
     ```javascript
     const worker = new Worker("worker.js");
     ```

3. **与 Worker 通信**：
   - 主线程使用 `postMessage` 向 Worker 发送消息。
   - Worker 使用 `onmessage` 接收消息，并使用 `postMessage` 返回消息。

4. **示例**：
   - 主线程代码：
     ```javascript
     const worker = new Worker("worker.js");
     
     worker.postMessage("Hello, Worker!");
     
     worker.onmessage = (event) => {
       console.log("从 Worker 收到消息：", event.data);
     };
     ```

   - Worker 文件（`worker.js`）：
     ```javascript
     onmessage = (event) => {
       console.log("从主线程收到消息：", event.data);
       postMessage("Hello from Worker!");
     };
     ```

5. **终止 Worker**：
   - 使用 `worker.terminate()` 终止 Worker。

---

## 19.3 Web 存储

1. **定义**：
   - Web 存储提供了两种存储方式：
     - `localStorage`：持久存储，数据不会随浏览器关闭而消失。
     - `sessionStorage`：会话存储，数据在页面会话结束时清除。

2. **常用方法**：
   - `setItem(key, value)`：存储数据。
   - `getItem(key)`：获取数据。
   - `removeItem(key)`：删除数据。
   - `clear()`：清空存储。

3. **示例**：
   ```javascript
   // localStorage 示例
   localStorage.setItem("username", "Alice");
   console.log(localStorage.getItem("username")); // "Alice"
   localStorage.removeItem("username");
   localStorage.clear();
   
   // sessionStorage 示例
   sessionStorage.setItem("sessionKey", "12345");
   console.log(sessionStorage.getItem("sessionKey")); // "12345"
   ```

---

## 19.4 Geolocation API

1. **定义**：
   - Geolocation API 提供获取用户地理位置信息的功能。

2. **方法**：
   - `getCurrentPosition(successCallback, errorCallback, options)`：获取当前位置。
   - `watchPosition(successCallback, errorCallback, options)`：持续监听位置变化。
   - `clearWatch(id)`：停止监听位置变化。

3. **示例**：
   ```javascript
   if (navigator.geolocation) {
     navigator.geolocation.getCurrentPosition(
       (position) => {
         console.log("纬度：", position.coords.latitude);
         console.log("经度：", position.coords.longitude);
       },
       (error) => {
         console.error("获取位置失败：", error.message);
       }
     );
   } else {
     console.log("Geolocation 不支持");
   }
   ```

---

## 19.5 File API

1. **定义**：
   - File API 提供了读取用户本地文件的能力。

2. **读取文件**：
   - 使用 `<input type="file">` 选择文件。
   - 使用 `FileReader` 读取文件内容。

3. **示例**：
   ```html
   <input type="file" id="fileInput" />
   <script>
     const fileInput = document.getElementById("fileInput");
   
     fileInput.addEventListener("change", (event) => {
       const file = event.target.files[0];
       const reader = new FileReader();
   
       reader.onload = () => {
         console.log("文件内容：", reader.result);
       };
   
       reader.readAsText(file); // 读取文件为文本
     });
   </script>
   ```

---

## 19.6 拖放 API

1. **定义**：
   - 拖放 API 提供了拖动和放置元素的功能。

2. **常用事件**：
   - `dragstart`：开始拖动。
   - `drag`：拖动中。
   - `dragend`：拖动结束。
   - `dragenter`：拖动进入目标区域。
   - `dragover`：拖动到目标区域上方。
   - `dragleave`：拖动离开目标区域。
   - `drop`：放置。

3. **示例**：
   ```html
   <div id="dragItem" draggable="true" style="width: 100px; height: 100px; background: red;"></div>
   <div id="dropZone" style="width: 200px; height: 200px; background: lightgray;"></div>
   
   <script>
     const dragItem = document.getElementById("dragItem");
     const dropZone = document.getElementById("dropZone");
   
     dragItem.addEventListener("dragstart", (event) => {
       event.dataTransfer.setData("text/plain", "This is a draggable item");
     });
   
     dropZone.addEventListener("dragover", (event) => {
       event.preventDefault(); // 必须阻止默认行为才能触发 drop 事件
     });
   
     dropZone.addEventListener("drop", (event) => {
       event.preventDefault();
       const data = event.dataTransfer.getData("text/plain");
       console.log("Dropped data:", data);
     });
   </script>
   ```

---

# 第十九章：经典面试题及解析

## 1. 如何实现跨文档消息传递？

### 答案：
使用 `postMessage` 方法发送消息，使用 `message` 事件接收消息。

### 示例：
```javascript
// 发送消息
const iframe = document.getElementById("myIframe");
iframe.contentWindow.postMessage("Hello from parent", "https://example.com");

// 接收消息
window.addEventListener("message", (event) => {
  if (event.origin === "https://example.com") {
    console.log("收到消息：", event.data);
  }
});
```

---

## 2. 如何创建和使用 Web Worker？

### 答案：
使用 `new Worker()` 创建 Worker，并通过 `postMessage` 和 `onmessage` 进行通信。

### 示例：
```javascript
// 主线程
const worker = new Worker("worker.js");
worker.postMessage("Hello, Worker!");
worker.onmessage = (event) => {
  console.log("从 Worker 收到消息：", event.data);
};

// Worker 文件（worker.js）
onmessage = (event) => {
  console.log("从主线程收到消息：", event.data);
  postMessage("Hello from Worker!");
};
```

---

## 3. 以下代码的输出是什么？

```javascript
localStorage.setItem("username", "Alice");
console.log(localStorage.getItem("username"));
localStorage.removeItem("username");
console.log(localStorage.getItem("username"));
```

### 答案：
输出：
```
Alice
null
```

---

## 4. 如何获取用户的地理位置信息？

### 答案：
使用 `navigator.geolocation.getCurrentPosition()`。

### 示例：
```javascript
navigator.geolocation.getCurrentPosition(
  (position) => {
    console.log("纬度：", position.coords.latitude);
    console.log("经度：", position.coords.longitude);
  },
  (error) => {
    console.error("获取位置失败：", error.message);
  }
);
```

---

## 5. 如何读取用户本地文件？

### 答案：
使用 `<input type="file">` 和 `FileReader`。

### 示例：
```javascript
const fileInput = document.getElementById("fileInput");

fileInput.addEventListener("change", (event) => {
  const file = event.target.files[0];
  const reader = new FileReader();

  reader.onload = () => {
    console.log("文件内容：", reader.result);
  };

  reader.readAsText(file);
});
```

---

## 6. 如何实现拖放功能？

### 答案：
使用拖放 API 的事件（如 `dragstart`、`dragover`、`drop`）。

### 示例：
```javascript
dragItem.addEventListener("dragstart", (event) => {
  event.dataTransfer.setData("text/plain", "This is a draggable item");
});

dropZone.addEventListener("dragover", (event) => {
  event.preventDefault();
});

dropZone.addEventListener("drop", (event) => {
  event.preventDefault();
  const data = event.dataTransfer.getData("text/plain");
  console.log("Dropped data:", data);
});
```

---

以上是《JavaScript高级程序设计》第19章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第20章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第20章：离线应用与客户端存储

## 20.1 离线检测

1. **定义**：
   - HTML5 提供了 `navigator.onLine` 属性和 `online`/`offline` 事件，用于检测用户是否处于在线状态。

2. **`navigator.onLine`**：
   - 返回布尔值，表示当前网络状态。
   - 示例：
     ```javascript
     console.log(navigator.onLine ? "在线" : "离线");
     ```

3. **`online` 和 `offline` 事件**：
   - 当网络状态发生变化时触发。
   - 示例：
     ```javascript
     window.addEventListener("online", () => {
       console.log("网络已连接");
     });
     
     window.addEventListener("offline", () => {
       console.log("网络已断开");
     });
     ```

---

## 20.2 应用缓存（Application Cache）

1. **定义**：
   - 应用缓存（`Application Cache`）允许开发者将 Web 应用的资源存储在本地，以便在离线时使用。

2. **应用缓存的工作原理**：
   - 使用 `manifest` 文件定义需要缓存的资源。
   - 浏览器会根据 `manifest` 文件下载并缓存资源。

3. **HTML 示例**：
   ```html
   <!DOCTYPE html>
   <html manifest="example.appcache">
   <head>
     <title>离线应用</title>
   </head>
   <body>
     <h1>离线应用示例</h1>
   </body>
   </html>
   ```

4. **`manifest` 文件示例**：
   ```plaintext
   CACHE MANIFEST
   # 版本号
   # v1.0
   
   CACHE:
   /index.html
   /styles.css
   /script.js
   
   NETWORK:
   *
   ```

5. **事件监听**：
   - 使用 `window.applicationCache` 监听缓存状态的变化。
   - 示例：
     ```javascript
     window.applicationCache.addEventListener("updateready", () => {
       if (window.applicationCache.status === window.applicationCache.UPDATEREADY) {
         window.applicationCache.swapCache();
         console.log("缓存已更新");
       }
     });
     ```

6. **注意**：
   - `Application Cache` 已被废弃，推荐使用 Service Workers。

---

## 20.3 IndexedDB

1. **定义**：
   - IndexedDB 是一种低级 API，用于在用户浏览器中存储大量结构化数据。

2. **特点**：
   - 支持事务。
   - 支持键值对存储。
   - 异步操作。

3. **基本操作**：
   - 打开数据库：`indexedDB.open(name, version)`
   - 创建对象存储：`db.createObjectStore(name, options)`
   - 添加数据：`objectStore.add(value, key)`
   - 读取数据：`objectStore.get(key)`

4. **示例**：
   ```javascript
   const request = indexedDB.open("myDatabase", 1);
   
   request.onupgradeneeded = (event) => {
     const db = event.target.result;
     if (!db.objectStoreNames.contains("users")) {
       db.createObjectStore("users", { keyPath: "id" });
     }
   };
   
   request.onsuccess = (event) => {
     const db = event.target.result;
     const transaction = db.transaction("users", "readwrite");
     const store = transaction.objectStore("users");
   
     // 添加数据
     store.add({ id: 1, name: "Alice" });
   
     // 读取数据
     const getRequest = store.get(1);
     getRequest.onsuccess = () => {
       console.log(getRequest.result); // { id: 1, name: "Alice" }
     };
   };
   
   request.onerror = (event) => {
     console.error("数据库打开失败", event);
   };
   ```

---

## 20.4 Service Workers

1. **定义**：
   - Service Workers 是一种运行在浏览器后台的脚本，用于拦截网络请求、缓存资源和实现离线功能。

2. **特点**：
   - 独立于主线程运行。
   - 支持离线缓存。
   - 可拦截和处理网络请求。

3. **注册 Service Worker**：
   ```javascript
   if ("serviceWorker" in navigator) {
     navigator.serviceWorker
       .register("/service-worker.js")
       .then((registration) => {
         console.log("Service Worker 注册成功", registration);
       })
       .catch((error) => {
         console.error("Service Worker 注册失败", error);
       });
   }
   ```

4. **Service Worker 示例**：
   - `service-worker.js` 文件：
     ```javascript
     self.addEventListener("install", (event) => {
       event.waitUntil(
         caches.open("my-cache").then((cache) => {
           return cache.addAll(["/", "/index.html", "/styles.css", "/script.js"]);
         })
       );
     });
     
     self.addEventListener("fetch", (event) => {
       event.respondWith(
         caches.match(event.request).then((response) => {
           return response || fetch(event.request);
         })
       );
     });
     ```

5. **生命周期**：
   - `install`：安装阶段。
   - `activate`：激活阶段。
   - `fetch`：拦截网络请求。

---

# 第20章：经典面试题及解析

## 1. 如何检测用户的网络状态？

### 答案：
使用 `navigator.onLine` 属性和 `online`/`offline` 事件。

### 示例：
```javascript
console.log(navigator.onLine ? "在线" : "离线");

window.addEventListener("online", () => {
  console.log("网络已连接");
});

window.addEventListener("offline", () => {
  console.log("网络已断开");
});
```

---

## 2. 什么是 Application Cache？它的作用是什么？

### 答案：
- **Application Cache** 是 HTML5 提供的一种离线缓存机制，用于在用户离线时访问 Web 应用。
- **作用**：
  - 缓存指定的资源。
  - 提供离线访问能力。

---

## 3. 以下代码的输出是什么？

```javascript
const request = indexedDB.open("myDatabase", 1);

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  db.createObjectStore("users", { keyPath: "id" });
};

request.onsuccess = (event) => {
  const db = event.target.result;
  const transaction = db.transaction("users", "readwrite");
  const store = transaction.objectStore("users");

  store.add({ id: 1, name: "Alice" });

  const getRequest = store.get(1);
  getRequest.onsuccess = () => {
    console.log(getRequest.result);
  };
};
```

### 答案：
输出：
```
{ id: 1, name: "Alice" }
```

---

## 4. 什么是 Service Worker？它的作用是什么？

### 答案：
- **Service Worker** 是一种运行在浏览器后台的脚本，用于拦截网络请求、缓存资源和实现离线功能。
- **作用**：
  1. 提供离线访问能力。
  2. 拦截和处理网络请求。
  3. 提高应用性能。

---

## 5. 如何注册一个 Service Worker？

### 答案：
使用 `navigator.serviceWorker.register()` 方法。

### 示例：
```javascript
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("/service-worker.js")
    .then((registration) => {
      console.log("Service Worker 注册成功", registration);
    })
    .catch((error) => {
      console.error("Service Worker 注册失败", error);
    });
}
```

---

## 6. 以下代码的输出是什么？

```javascript
self.addEventListener("fetch", (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

### 答案：
- 如果请求的资源已被缓存，则返回缓存的资源。
- 如果资源未被缓存，则通过网络请求获取资源。

---

以上是《JavaScript高级程序设计》第20章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第21章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第21章：模块

## 21.1 模块化的概述

1. **定义**：
   - 模块化是一种将代码分割为独立、可复用部分的技术，每个模块封装特定的功能。

2. **模块化的优点**：
   - 提高代码的可维护性。
   - 避免全局变量污染。
   - 支持代码复用。

3. **模块化的实现方式**：
   - 早期的模块化方案：IIFE、CommonJS、AMD。
   - 现代模块化方案：ES6 模块（`import` 和 `export`）。

---

## 21.2 ES6 模块

1. **基本语法**：
   - 使用 `export` 导出模块。
   - 使用 `import` 导入模块。

2. **导出模块**：
   - **命名导出**：
     ```javascript
     // filepath: math.js
     export const add = (a, b) => a + b;
     export const subtract = (a, b) => a - b;
     ```

   - **默认导出**：
     ```javascript
     // filepath: math.js
     export default function multiply(a, b) {
       return a * b;
     }
     ```

3. **导入模块**：
   - **导入命名导出**：
     ```javascript
     import { add, subtract } from "./math.js";
     console.log(add(2, 3)); // 5
     console.log(subtract(5, 2)); // 3
     ```

   - **导入默认导出**：
     ```javascript
     import multiply from "./math.js";
     console.log(multiply(2, 3)); // 6
     ```

   - **导入所有导出**：
     ```javascript
     import * as math from "./math.js";
     console.log(math.add(2, 3)); // 5
     console.log(math.subtract(5, 2)); // 3
     ```

4. **重命名导出和导入**：
   - 导出时重命名：
     ```javascript
     export { add as addition };
     ```
   - 导入时重命名：
     ```javascript
     import { add as addition } from "./math.js";
     ```

---

## 21.3 动态导入

1. **定义**：
   - 使用 `import()` 函数动态加载模块，返回一个 `Promise`。

2. **示例**：
   ```javascript
   import("./math.js").then((module) => {
     console.log(module.add(2, 3)); // 5
   });
   ```

3. **应用场景**：
   - 按需加载模块。
   - 实现代码分割。

---

## 21.4 CommonJS 模块

1. **定义**：
   - CommonJS 是 Node.js 中的模块化规范，使用 `require` 和 `module.exports`。

2. **导出模块**：
   ```javascript
   // filepath: math.js
   const add = (a, b) => a + b;
   const subtract = (a, b) => a - b;
   
   module.exports = { add, subtract };
   ```

3. **导入模块**：
   ```javascript
   const math = require("./math.js");
   console.log(math.add(2, 3)); // 5
   console.log(math.subtract(5, 2)); // 3
   ```

4. **特点**：
   - 模块是同步加载的。
   - 适用于服务器端环境。

---

## 21.5 AMD 模块

1. **定义**：
   - AMD（Asynchronous Module Definition）是一种异步模块加载规范，常用于浏览器环境。

2. **使用 `define` 定义模块**：
   ```javascript
   define("math", [], function () {
     return {
       add: function (a, b) {
         return a + b;
       },
       subtract: function (a, b) {
         return a - b;
       },
     };
   });
   ```

3. **使用 `require` 加载模块**：
   ```javascript
   require(["math"], function (math) {
     console.log(math.add(2, 3)); // 5
   });
   ```

4. **特点**：
   - 模块是异步加载的。
   - 适用于浏览器环境。

---

## 21.6 UMD 模块

1. **定义**：
   - UMD（Universal Module Definition）是一种兼容 CommonJS 和 AMD 的模块化规范。

2. **示例**：
   ```javascript
   (function (root, factory) {
     if (typeof define === "function" && define.amd) {
       // AMD
       define([], factory);
     } else if (typeof module === "object" && module.exports) {
       // CommonJS
       module.exports = factory();
     } else {
       // 全局变量
       root.math = factory();
     }
   })(this, function () {
     return {
       add: function (a, b) {
         return a + b;
       },
       subtract: function (a, b) {
         return a - b;
       },
     };
   });
   ```

---

# 第21章：经典面试题及解析

## 1. 什么是模块化？模块化的优点是什么？

### 答案：
- **模块化**是一种将代码分割为独立、可复用部分的技术，每个模块封装特定的功能。
- **优点**：
  1. 提高代码的可维护性。
  2. 避免全局变量污染。
  3. 支持代码复用。

---

## 2. 以下代码的输出是什么？

```javascript
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;

// filepath: main.js
import { add, subtract } from "./math.js";
console.log(add(2, 3));
console.log(subtract(5, 2));
```

### 答案：
输出：
```
5
3
```

---

## 3. 如何使用 ES6 模块导入默认导出？

### 答案：
使用 `import defaultExport from "module"`。

### 示例：
```javascript
export default function multiply(a, b) {
  return a * b;
}

// filepath: main.js
import multiply from "./math.js";
console.log(multiply(2, 3)); // 6
```

---

## 4. 什么是动态导入？它的应用场景是什么？

### 答案：
- **动态导入**是使用 `import()` 函数按需加载模块，返回一个 `Promise`。
- **应用场景**：
  1. 按需加载模块。
  2. 实现代码分割。

### 示例：
```javascript
import("./math.js").then((module) => {
  console.log(module.add(2, 3)); // 5
});
```

---

## 5. CommonJS 和 ES6 模块的区别是什么？

### 答案：
| 特性     | CommonJS         | ES6 模块         |
| -------- | ---------------- | ---------------- |
| 导入语法 | `require()`      | `import`         |
| 导出语法 | `module.exports` | `export`         |
| 加载方式 | 同步加载         | 异步加载         |
| 适用环境 | Node.js          | 浏览器和 Node.js |

---

## 6. 以下代码的输出是什么？

```javascript
module.exports = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
};

// filepath: main.js
const math = require("./math.js");
console.log(math.add(2, 3));
console.log(math.subtract(5, 2));
```

### 答案：
输出：
```
5
3
```

---

## 7. 什么是 UMD 模块？它的作用是什么？

### 答案：
- **UMD 模块**（Universal Module Definition）是一种兼容 CommonJS 和 AMD 的模块化规范。
- **作用**：
  - 使模块可以在多种环境（如浏览器、Node.js）中使用。

---

以上是《JavaScript高级程序设计》第21章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第22章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第22章：JSON

## 22.1 JSON 的概述

1. **定义**：
   - JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，易于人类阅读和编写，也易于机器解析和生成。

2. **特点**：
   - 基于键值对的结构。
   - 数据类型支持：字符串、数字、布尔值、数组、对象和 `null`。
   - 不支持函数、`undefined` 和特殊对象（如 `Date`、`RegExp`）。

3. **JSON 的用途**：
   - 数据存储。
   - 数据交换（如客户端与服务器之间的通信）。

4. **JSON 示例**：
   ```json
   {
     "name": "Alice",
     "age": 25,
     "isStudent": false,
     "skills": ["JavaScript", "HTML", "CSS"],
     "address": {
       "city": "New York",
       "zip": "10001"
     }
   }
   ```

---

## 22.2 JSON 的语法规则

1. **对象**：
   - 使用花括号 `{}` 表示。
   - 键必须是双引号包裹的字符串。
   - 示例：
     ```json
     {
       "name": "Alice",
       "age": 25
     }
     ```

2. **数组**：
   - 使用方括号 `[]` 表示。
   - 示例：
     ```json
     ["JavaScript", "HTML", "CSS"]
     ```

3. **值**：
   - 可以是字符串、数字、布尔值、数组、对象或 `null`。
   - 示例：
     ```json
     {
       "isStudent": false,
       "score": null
     }
     ```

4. **不支持的内容**：
   - 函数、`undefined`、`NaN`、`Infinity`、`Date`、`RegExp` 等。

---

## 22.3 JSON 对象

1. **`JSON.stringify()`**：
   - 将 JavaScript 对象转换为 JSON 字符串。
   - 语法：
     ```javascript
     JSON.stringify(value, replacer, space);
     ```
     - `value`：要转换的值。
     - `replacer`（可选）：用于筛选或修改值的函数或数组。
     - `space`（可选）：用于格式化输出的空格或缩进。

   - 示例：
     ```javascript
     const obj = { name: "Alice", age: 25 };
     const jsonString = JSON.stringify(obj);
     console.log(jsonString); // '{"name":"Alice","age":25}'
     ```

   - 格式化输出：
     ```javascript
     const jsonString = JSON.stringify(obj, null, 2);
     console.log(jsonString);
     ```

   - 使用 `replacer`：
     ```javascript
     const jsonString = JSON.stringify(obj, ["name"]);
     console.log(jsonString); // '{"name":"Alice"}'
     ```

2. **`JSON.parse()`**：
   - 将 JSON 字符串解析为 JavaScript 对象。
   - 语法：
     ```javascript
     JSON.parse(text, reviver);
     ```
     - `text`：要解析的 JSON 字符串。
     - `reviver`（可选）：用于转换值的函数。

   - 示例：
     ```javascript
     const jsonString = '{"name":"Alice","age":25}';
     const obj = JSON.parse(jsonString);
     console.log(obj.name); // "Alice"
     ```

   - 使用 `reviver`：
     ```javascript
     const obj = JSON.parse(jsonString, (key, value) => {
       if (key === "age") {
         return value + 1;
       }
       return value;
     });
     console.log(obj.age); // 26
     ```

---

## 22.4 JSON 的应用场景

1. **数据存储**：
   - 使用 `localStorage` 或 `sessionStorage` 存储 JSON 数据。
   - 示例：
     ```javascript
     const obj = { name: "Alice", age: 25 };
     localStorage.setItem("user", JSON.stringify(obj));
     
     const user = JSON.parse(localStorage.getItem("user"));
     console.log(user.name); // "Alice"
     ```

2. **数据交换**：
   - 在客户端与服务器之间传递数据。
   - 示例：
     ```javascript
     fetch("https://api.example.com/data")
       .then((response) => response.json())
       .then((data) => {
         console.log(data);
       });
     ```

3. **配置文件**：
   - JSON 常用于存储配置数据（如 `.json` 文件）。

---

## 22.5 JSON 的局限性

1. **不支持复杂数据类型**：
   - JSON 不支持函数、`undefined`、`Date`、`RegExp` 等。

2. **安全性问题**：
   - 解析不可信的 JSON 字符串可能导致安全问题。
   - 示例：
     ```javascript
     const jsonString = '{"__proto__":{"polluted":"yes"}}';
     const obj = JSON.parse(jsonString);
     console.log(obj.polluted); // undefined
     console.log({}.polluted); // "yes"（可能导致原型污染）
     ```

3. **性能问题**：
   - 对于大型数据集，`JSON.stringify` 和 `JSON.parse` 的性能可能成为瓶颈。

---

# 第22章：经典面试题及解析

## 1. 什么是 JSON？JSON 的用途是什么？

### 答案：
- **JSON**（JavaScript Object Notation）是一种轻量级的数据交换格式，基于键值对的结构。
- **用途**：
  1. 数据存储。
  2. 客户端与服务器之间的数据交换。
  3. 配置文件。

---

## 2. 以下代码的输出是什么？

```javascript
const obj = { name: "Alice", age: 25 };
const jsonString = JSON.stringify(obj);
console.log(jsonString);
```

### 答案：
输出：
```
'{"name":"Alice","age":25}'
```

---

## 3. 如何将 JSON 字符串解析为 JavaScript 对象？

### 答案：
使用 `JSON.parse()` 方法。

### 示例：
```javascript
const jsonString = '{"name":"Alice","age":25}';
const obj = JSON.parse(jsonString);
console.log(obj.name); // "Alice"
```

---

## 4. 以下代码的输出是什么？

```javascript
const obj = { name: "Alice", age: 25 };
const jsonString = JSON.stringify(obj, null, 2);
console.log(jsonString);
```

### 答案：
输出：
```json
{
  "name": "Alice",
  "age": 25
}
```

### 解析：
- `null` 表示不使用 `replacer`。
- `2` 表示每层缩进 2 个空格。

---

## 5. 如何使用 `JSON.stringify` 筛选对象的部分属性？

### 答案：
通过 `replacer` 参数筛选属性。

### 示例：
```javascript
const obj = { name: "Alice", age: 25, city: "New York" };
const jsonString = JSON.stringify(obj, ["name", "city"]);
console.log(jsonString); // '{"name":"Alice","city":"New York"}'
```

---

## 6. 以下代码的输出是什么？

```javascript
const jsonString = '{"name":"Alice","age":25}';
const obj = JSON.parse(jsonString, (key, value) => {
  if (key === "age") {
    return value + 1;
  }
  return value;
});
console.log(obj.age);
```

### 答案：
输出：
```
26
```

### 解析：
- `reviver` 函数对 `age` 属性的值进行了修改。

---

## 7. JSON 的局限性有哪些？

### 答案：
1. 不支持复杂数据类型（如函数、`undefined`、`Date`、`RegExp`）。
2. 解析不可信的 JSON 字符串可能导致安全问题（如原型污染）。
3. 对于大型数据集，`JSON.stringify` 和 `JSON.parse` 的性能可能成为瓶颈。

---

## 8. 如何使用 JSON 存储和读取数据到 `localStorage`？

### 答案：
使用 `JSON.stringify` 和 `JSON.parse`。

### 示例：
```javascript
const obj = { name: "Alice", age: 25 };
localStorage.setItem("user", JSON.stringify(obj));

const user = JSON.parse(localStorage.getItem("user"));
console.log(user.name); // "Alice"
```

---

以上是《JavaScript高级程序设计》第22章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。



以下是《JavaScript高级程序设计》第23章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第23章：网络请求与远程资源

## 23.1 XMLHttpRequest

1. **定义**：
   - `XMLHttpRequest` 是一种用于与服务器交互的 API，可以在不重新加载页面的情况下发送和接收数据。

2. **基本用法**：
   - 创建 `XMLHttpRequest` 对象。
   - 调用 `open()` 方法初始化请求。
   - 调用 `send()` 方法发送请求。
   - 监听 `readystatechange` 事件处理响应。

3. **示例**：
   ```javascript
   const xhr = new XMLHttpRequest();
   xhr.open("GET", "https://api.example.com/data", true);
   
   xhr.onreadystatechange = () => {
     if (xhr.readyState === 4 && xhr.status === 200) {
       console.log(JSON.parse(xhr.responseText));
     }
   };
   
   xhr.send();
   ```

4. **`readyState` 的值**：
   - `0`：未初始化。
   - `1`：已打开。
   - `2`：已发送。
   - `3`：正在接收。
   - `4`：完成。

5. **常用属性**：
   - `xhr.responseText`：响应的文本内容。
   - `xhr.status`：HTTP 状态码。
   - `xhr.statusText`：HTTP 状态文本。

---

## 23.2 Fetch API

1. **定义**：
   - `Fetch API` 是现代浏览器提供的一种用于发送网络请求的接口，基于 `Promise`。

2. **基本用法**：
   - 使用 `fetch()` 方法发送请求。
   - 返回一个 `Promise`，解析为 `Response` 对象。

3. **示例**：
   ```javascript
   fetch("https://api.example.com/data")
     .then((response) => {
       if (!response.ok) {
         throw new Error(`HTTP error! status: ${response.status}`);
       }
       return response.json();
     })
     .then((data) => {
       console.log(data);
     })
     .catch((error) => {
       console.error("Fetch error:", error);
     });
   ```

4. **发送 POST 请求**：
   ```javascript
   fetch("https://api.example.com/data", {
     method: "POST",
     headers: {
       "Content-Type": "application/json",
     },
     body: JSON.stringify({ name: "Alice", age: 25 }),
   })
     .then((response) => response.json())
     .then((data) => console.log(data))
     .catch((error) => console.error("Error:", error));
   ```

5. **特点**：
   - 基于 `Promise`，更简洁。
   - 默认不发送跨域请求的 `Cookie`，需要设置 `credentials`。

---

## 23.3 跨域资源共享（CORS）

1. **定义**：
   - CORS（Cross-Origin Resource Sharing）是一种机制，允许浏览器向不同源的服务器发起请求。

2. **同源策略**：
   - 同源策略要求协议、域名和端口号必须相同。
   - 不同源的请求会被浏览器阻止。

3. **CORS 的实现**：
   - 服务器通过设置 HTTP 响应头来允许跨域请求。
   - 常见的 CORS 响应头：
     - `Access-Control-Allow-Origin`：指定允许的源。
     - `Access-Control-Allow-Methods`：允许的 HTTP 方法。
     - `Access-Control-Allow-Headers`：允许的自定义头。

4. **示例**：
   - 服务器设置：
     ```http
     Access-Control-Allow-Origin: https://example.com
     Access-Control-Allow-Methods: GET, POST
     Access-Control-Allow-Headers: Content-Type
     ```

5. **预检请求**：
   - 对于复杂请求（如 `PUT`、`DELETE` 或带自定义头的请求），浏览器会先发送 `OPTIONS` 请求进行预检。

---

## 23.4 WebSocket

1. **定义**：
   - WebSocket 是一种全双工通信协议，允许客户端和服务器之间实时通信。

2. **特点**：
   - 基于 TCP 协议。
   - 支持双向通信。
   - 更适合实时应用（如聊天、游戏）。

3. **基本用法**：
   - 创建 WebSocket 连接。
   - 监听 `open`、`message`、`error` 和 `close` 事件。

4. **示例**：
   ```javascript
   const socket = new WebSocket("wss://example.com/socket");
   
   socket.addEventListener("open", () => {
     console.log("WebSocket 连接已建立");
     socket.send("Hello, Server!");
   });
   
   socket.addEventListener("message", (event) => {
     console.log("收到消息：", event.data);
   });
   
   socket.addEventListener("close", () => {
     console.log("WebSocket 连接已关闭");
   });
   
   socket.addEventListener("error", (error) => {
     console.error("WebSocket 错误：", error);
   });
   ```

---

## 23.5 Server-Sent Events (SSE)

1. **定义**：
   - SSE（服务器发送事件）是一种单向通信技术，服务器可以向客户端推送实时数据。

2. **特点**：
   - 基于 HTTP 协议。
   - 只支持服务器到客户端的单向通信。

3. **基本用法**：
   - 客户端使用 `EventSource` 接收数据。
   - 服务器发送 `text/event-stream` 格式的数据。

4. **示例**：
   - 客户端代码：
     ```javascript
     const eventSource = new EventSource("https://example.com/events");
     
     eventSource.onmessage = (event) => {
       console.log("收到消息：", event.data);
     };
     
     eventSource.onerror = (error) => {
       console.error("SSE 错误：", error);
     };
     ```

   - 服务器响应：
     ```http
     Content-Type: text/event-stream
     
     data: Hello, Client!
     ```

---

# 第23章：经典面试题及解析

## 1. 什么是 XMLHttpRequest？如何使用它发送 GET 请求？

### 答案：
- **XMLHttpRequest** 是一种用于与服务器交互的 API，可以在不重新加载页面的情况下发送和接收数据。
- **示例**：
  ```javascript
  const xhr = new XMLHttpRequest();
  xhr.open("GET", "https://api.example.com/data", true);
  
  xhr.onreadystatechange = () => {
    if (xhr.readyState === 4 && xhr.status === 200) {
      console.log(JSON.parse(xhr.responseText));
    }
  };
  
  xhr.send();
  ```

---

## 2. 以下代码的输出是什么？

```javascript
fetch("https://api.example.com/data")
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

### 答案：
- 如果请求成功，输出服务器返回的 JSON 数据。
- 如果请求失败，输出错误信息。

---

## 3. 什么是 CORS？如何实现跨域请求？

### 答案：
- **CORS**（跨域资源共享）是一种机制，允许浏览器向不同源的服务器发起请求。
- **实现**：
  - 服务器设置响应头：
    ```http
    Access-Control-Allow-Origin: https://example.com
    Access-Control-Allow-Methods: GET, POST
    Access-Control-Allow-Headers: Content-Type
    ```

---

## 4. 什么是 WebSocket？它的特点是什么？

### 答案：
- **WebSocket** 是一种全双工通信协议，允许客户端和服务器之间实时通信。
- **特点**：
  1. 基于 TCP 协议。
  2. 支持双向通信。
  3. 适合实时应用（如聊天、游戏）。

---

## 5. 以下代码的输出是什么？

```javascript
const socket = new WebSocket("wss://example.com/socket");

socket.addEventListener("open", () => {
  console.log("WebSocket 连接已建立");
  socket.send("Hello, Server!");
});

socket.addEventListener("message", (event) => {
  console.log("收到消息：", event.data);
});
```

### 答案：
- 输出：
  ```
  WebSocket 连接已建立
  收到消息：<服务器返回的消息>
  ```

---

## 6. 什么是 Server-Sent Events (SSE)？它的特点是什么？

### 答案：
- **SSE** 是一种单向通信技术，服务器可以向客户端推送实时数据。
- **特点**：
  1. 基于 HTTP 协议。
  2. 只支持服务器到客户端的单向通信。

---

以上是《JavaScript高级程序设计》第23章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第24章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第24章：最佳实践

## 24.1 可维护性

1. **定义**：
   - 可维护性是指代码易于理解、修改和扩展的能力。

2. **提高可维护性的原则**：
   - 遵循 **KISS 原则**（Keep It Simple, Stupid）：保持代码简单。
   - 遵循 **DRY 原则**（Don't Repeat Yourself）：避免重复代码。
   - 遵循 **单一职责原则**：每个函数或模块只负责一件事。

3. **实践**：
   - 使用清晰的命名：
     ```javascript
     // 不推荐
     const x = 10;
     
     // 推荐
     const maxUsers = 10;
     ```
   - 避免深层嵌套：
     ```javascript
     // 不推荐
     if (condition1) {
       if (condition2) {
         if (condition3) {
           // ...
         }
       }
     }
     
     // 推荐
     if (!condition1 || !condition2 || !condition3) return;
     ```

---

## 24.2 性能优化

1. **减少 DOM 操作**：
   - DOM 操作是性能瓶颈，应尽量减少。
   - 示例：
     ```javascript
     // 不推荐
     for (let i = 0; i < 1000; i++) {
       const div = document.createElement("div");
       document.body.appendChild(div);
     }
     
     // 推荐
     const fragment = document.createDocumentFragment();
     for (let i = 0; i < 1000; i++) {
       const div = document.createElement("div");
       fragment.appendChild(div);
     }
     document.body.appendChild(fragment);
     ```

2. **事件委托**：
   - 将事件监听器绑定到父元素，减少事件绑定数量。
   - 示例：
     ```javascript
     const parent = document.getElementById("parent");
     parent.addEventListener("click", (event) => {
       if (event.target.tagName === "BUTTON") {
         console.log("Button clicked:", event.target.textContent);
       }
     });
     ```

3. **使用节流和防抖**：
   - **节流**：限制函数的执行频率。
   - **防抖**：延迟函数的执行，直到事件停止触发。
   - 示例：
     ```javascript
     // 节流
     function throttle(func, delay) {
       let lastTime = 0;
       return function (...args) {
         const now = Date.now();
         if (now - lastTime >= delay) {
           lastTime = now;
           func.apply(this, args);
         }
       };
     }
     
     // 防抖
     function debounce(func, delay) {
       let timer;
       return function (...args) {
         clearTimeout(timer);
         timer = setTimeout(() => func.apply(this, args), delay);
       };
     }
     ```

4. **异步加载资源**：
   - 使用 `async` 或 `defer` 属性加载脚本。
   - 示例：
     ```html
     <script src="script.js" async></script>
     <script src="script.js" defer></script>
     ```

---

## 24.3 安全性

1. **防止 XSS（跨站脚本攻击）**：
   - 对用户输入进行转义或验证。
   - 示例：
     ```javascript
     function escapeHTML(str) {
       return str.replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
     }
     ```

2. **防止 CSRF（跨站请求伪造）**：
   - 使用 CSRF 令牌验证请求来源。
   - 示例：
     ```javascript
     const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
     fetch("/api/data", {
       method: "POST",
       headers: {
         "Content-Type": "application/json",
         "X-CSRF-Token": csrfToken,
       },
       body: JSON.stringify({ key: "value" }),
     });
     ```

3. **避免使用 `eval`**：
   - `eval` 会执行任意字符串代码，容易导致安全漏洞。
   - 示例：
     ```javascript
     // 不推荐
     eval("console.log('Hello, World!')");
     
     // 推荐
     console.log("Hello, World!");
     ```

---

## 24.4 调试技巧

1. **使用断点调试**：
   - 在浏览器开发者工具中设置断点，逐步调试代码。

2. **使用 `console` 方法**：
   - `console.log()`：输出普通日志。
   - `console.error()`：输出错误信息。
   - `console.warn()`：输出警告信息。
   - `console.table()`：以表格形式输出数据。
   - 示例：
     ```javascript
     const users = [
       { id: 1, name: "Alice" },
       { id: 2, name: "Bob" },
     ];
     console.table(users);
     ```

3. **捕获未处理的错误**：
   - 使用 `window.onerror` 或 `window.addEventListener("error")` 捕获全局错误。
   - 示例：
     ```javascript
     window.addEventListener("error", (event) => {
       console.error("捕获到错误：", event.message);
     });
     ```

4. **使用性能分析工具**：
   - 浏览器开发者工具中的 Performance 面板可以分析代码性能瓶颈。

---

## 24.5 代码规范

1. **使用一致的代码风格**：
   - 使用工具（如 ESLint、Prettier）强制执行代码规范。

2. **避免魔法数字**：
   - 使用常量代替硬编码的数字。
   - 示例：
     ```javascript
     // 不推荐
     if (user.age > 18) {
       // ...
     }
     
     // 推荐
     const MIN_AGE = 18;
     if (user.age > MIN_AGE) {
       // ...
     }
     ```

3. **注释代码**：
   - 为复杂逻辑添加注释，说明代码的意图。
   - 示例：
     ```javascript
     // 检查用户是否已登录
     if (user.isLoggedIn) {
       // ...
     }
     ```

4. **模块化代码**：
   - 将代码分割为独立的模块，避免文件过于庞大。

---

# 第24章：经典面试题及解析

## 1. 如何提高代码的可维护性？

### 答案：
1. 遵循 KISS 原则（保持简单）。
2. 遵循 DRY 原则（避免重复代码）。
3. 遵循单一职责原则。
4. 使用清晰的命名。
5. 避免深层嵌套。

---

## 2. 以下代码的输出是什么？

```javascript
function throttle(func, delay) {
  let lastTime = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      lastTime = now;
      func.apply(this, args);
    }
  };
}

const log = throttle(() => console.log("Throttled!"), 1000);

log();
log();
setTimeout(log, 1500);
```

### 答案：
输出：
```
Throttled!
Throttled!
```

### 解析：
- 第一次调用立即执行。
- 第二次调用在 1000ms 内被忽略。
- 第三次调用在 1500ms 后执行。

---

## 3. 如何防止 XSS 攻击？

### 答案：
1. 对用户输入进行转义或验证。
2. 使用安全的模板引擎。
3. 避免直接插入用户输入到 HTML 中。

### 示例：
```javascript
function escapeHTML(str) {
  return str.replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
}
```

---

## 4. 以下代码的输出是什么？

```javascript
const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
];
console.table(users);
```

### 答案：
输出一个表格，显示用户的 `id` 和 `name`。

---

## 5. 为什么要使用事件委托？

### 答案：
1. 减少事件监听器的数量，优化性能。
2. 动态绑定子元素的事件。

### 示例：
```javascript
const parent = document.getElementById("parent");
parent.addEventListener("click", (event) => {
  if (event.target.tagName === "BUTTON") {
    console.log("Button clicked:", event.target.textContent);
  }
});
```

---

## 6. 如何捕获全局错误？

### 答案：
使用 `window.onerror` 或 `window.addEventListener("error")`。

### 示例：
```javascript
window.addEventListener("error", (event) => {
  console.error("捕获到错误：", event.message);
});
```

---

以上是《JavaScript高级程序设计》第24章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

以下是《JavaScript高级程序设计》第25章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用：

---

# 第25章：新兴的 API

## 25.1 Web Components

1. **定义**：
   - Web Components 是一组用于创建可复用、自定义 HTML 元素的技术，包括：
     - **Custom Elements**：自定义元素。
     - **Shadow DOM**：封装样式和逻辑。
     - **HTML Templates**：模板和插槽。

2. **Custom Elements（自定义元素）**：
   - 使用 `customElements.define()` 定义自定义元素。
   - 示例：
     ```javascript
     class MyElement extends HTMLElement {
       connectedCallback() {
         this.innerHTML = "<p>Hello, Web Components!</p>";
       }
     }
     customElements.define("my-element", MyElement);
     ```

   - 使用：
     ```html
     <my-element></my-element>
     ```

3. **Shadow DOM**：
   - 使用 `attachShadow()` 创建 Shadow DOM。
   - 示例：
     ```javascript
     class MyElement extends HTMLElement {
       constructor() {
         super();
         const shadow = this.attachShadow({ mode: "open" });
         shadow.innerHTML = `
           <style>
             p { color: red; }
           </style>
           <p>Hello, Shadow DOM!</p>
         `;
       }
     }
     customElements.define("my-element", MyElement);
     ```

4. **HTML Templates**：
   - 使用 `<template>` 定义模板。
   - 示例：
     ```html
     <template id="my-template">
       <style>
         p { color: blue; }
       </style>
       <p>Hello, Template!</p>
     </template>
     
     <script>
       const template = document.getElementById("my-template");
       const content = template.content.cloneNode(true);
       document.body.appendChild(content);
     </script>
     ```

---

## 25.2 WebRTC

1. **定义**：
   - WebRTC（Web Real-Time Communication）是一种支持浏览器之间实时音视频通信的 API。

2. **主要功能**：
   - 获取媒体流（音频、视频）。
   - 点对点连接。
   - 数据通道传输。

3. **获取媒体流**：
   - 使用 `navigator.mediaDevices.getUserMedia()`。
   - 示例：
     ```javascript
     navigator.mediaDevices
       .getUserMedia({ video: true, audio: true })
       .then((stream) => {
         const video = document.querySelector("video");
         video.srcObject = stream;
       })
       .catch((error) => {
         console.error("获取媒体流失败：", error);
       });
     ```

4. **点对点连接**：
   - 使用 `RTCPeerConnection` 创建连接。
   - 示例：
     ```javascript
     const peerConnection = new RTCPeerConnection();
     peerConnection.onicecandidate = (event) => {
       if (event.candidate) {
         console.log("ICE Candidate:", event.candidate);
       }
     };
     ```

---

## 25.3 Web Speech API

1. **定义**：
   - Web Speech API 提供了语音识别和语音合成功能。

2. **语音合成**：
   - 使用 `SpeechSynthesis`。
   - 示例：
     ```javascript
     const utterance = new SpeechSynthesisUtterance("Hello, Web Speech API!");
     speechSynthesis.speak(utterance);
     ```

3. **语音识别**：
   - 使用 `SpeechRecognition`。
   - 示例：
     ```javascript
     const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
     recognition.onresult = (event) => {
       console.log("识别结果：", event.results[0][0].transcript);
     };
     recognition.start();
     ```

---

## 25.4 Notifications API

1. **定义**：
   - Notifications API 用于向用户显示桌面通知。

2. **权限请求**：
   - 使用 `Notification.requestPermission()` 请求权限。
   - 示例：
     ```javascript
     Notification.requestPermission().then((permission) => {
       if (permission === "granted") {
         new Notification("Hello, Notifications API!");
       }
     });
     ```

3. **创建通知**：
   - 使用 `new Notification()`。
   - 示例：
     ```javascript
     const notification = new Notification("New Message", {
       body: "You have a new message!",
       icon: "icon.png",
     });
     ```

---

## 25.5 Battery Status API

1. **定义**：
   - Battery Status API 提供设备电池状态的信息。

2. **获取电池信息**：
   - 使用 `navigator.getBattery()`。
   - 示例：
     ```javascript
     navigator.getBattery().then((battery) => {
       console.log("电量：", battery.level * 100 + "%");
       console.log("是否正在充电：", battery.charging);
     });
     ```

3. **监听电池状态变化**：
   - 示例：
     ```javascript
     navigator.getBattery().then((battery) => {
       battery.addEventListener("levelchange", () => {
         console.log("电量变化：", battery.level * 100 + "%");
       });
     });
     ```

---

## 25.6 Device Orientation API

1. **定义**：
   - Device Orientation API 提供设备方向和运动的相关信息。

2. **监听设备方向**：
   - 使用 `deviceorientation` 事件。
   - 示例：
     ```javascript
     window.addEventListener("deviceorientation", (event) => {
       console.log("Alpha:", event.alpha);
       console.log("Beta:", event.beta);
       console.log("Gamma:", event.gamma);
     });
     ```

3. **监听设备运动**：
   - 使用 `devicemotion` 事件。
   - 示例：
     ```javascript
     window.addEventListener("devicemotion", (event) => {
       console.log("加速度：", event.acceleration);
       console.log("旋转速率：", event.rotationRate);
     });
     ```

---

# 第25章：经典面试题及解析

## 1. 什么是 Web Components？它由哪些技术组成？

### 答案：
- **Web Components** 是一组用于创建可复用、自定义 HTML 元素的技术。
- **组成**：
  1. Custom Elements（自定义元素）。
  2. Shadow DOM（封装样式和逻辑）。
  3. HTML Templates（模板和插槽）。

---

## 2. 以下代码的输出是什么？

```javascript
class MyElement extends HTMLElement {
  connectedCallback() {
    this.innerHTML = "<p>Hello, Web Components!</p>";
  }
}
customElements.define("my-element", MyElement);
```

```html
<my-element></my-element>
```

### 答案：
输出：
```
<p>Hello, Web Components!</p>
```

---

## 3. 如何使用 WebRTC 获取用户的摄像头和麦克风？

### 答案：
使用 `navigator.mediaDevices.getUserMedia()`。

### 示例：
```javascript
navigator.mediaDevices
  .getUserMedia({ video: true, audio: true })
  .then((stream) => {
    const video = document.querySelector("video");
    video.srcObject = stream;
  })
  .catch((error) => {
    console.error("获取媒体流失败：", error);
  });
```

---

## 4. 如何使用 Web Speech API 实现语音合成？

### 答案：
使用 `SpeechSynthesis`。

### 示例：
```javascript
const utterance = new SpeechSynthesisUtterance("Hello, Web Speech API!");
speechSynthesis.speak(utterance);
```

---

## 5. 如何向用户显示桌面通知？

### 答案：
使用 `Notifications API`。

### 示例：
```javascript
Notification.requestPermission().then((permission) => {
  if (permission === "granted") {
    new Notification("Hello, Notifications API!");
  }
});
```

---

## 6. 如何获取设备的电池状态？

### 答案：
使用 `navigator.getBattery()`。

### 示例：
```javascript
navigator.getBattery().then((battery) => {
  console.log("电量：", battery.level * 100 + "%");
  console.log("是否正在充电：", battery.charging);
});
```

---

## 7. 以下代码的输出是什么？

```javascript
window.addEventListener("deviceorientation", (event) => {
  console.log("Alpha:", event.alpha);
  console.log("Beta:", event.beta);
  console.log("Gamma:", event.gamma);
});
```

### 答案：
- 输出设备的方向信息：
  ```
  Alpha: <设备绕 Z 轴的旋转角度>
  Beta: <设备绕 X 轴的旋转角度>
  Gamma: <设备绕 Y 轴的旋转角度>
  ```

---

以上是《JavaScript高级程序设计》第25章的详细笔记和经典面试题，格式化为 Markdown，方便复制和使用。

